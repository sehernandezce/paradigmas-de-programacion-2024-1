<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Prolog by mppinedav</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <script type="text/javascript" src="js/prolog.js"></script>
    <script type="text/javascript"
  src="https://www.maths.nottingham.ac.uk/plp/pmadw/LaTeXMathML.js">
    </script>

  </head>
  <body>
  

<div id="google_translate_element"></div>
    <section class="page-header">
      <h1 class="project-name">Prolog</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/ferestrepoca/paradigmas-de-programacion/tree/gh-pages/proglogica/tutoriales/prolog-gh-pages" class="btn">View on GitHub</a>
    </section>

    <section class="main-content">
    <button onclick="topFunction()" id="myBtn" title="Go to top">Contenido</button>

      <p align="center">
<img src="https://avatars2.githubusercontent.com/u/6884283?v=3&amp;s=200">
</p>

<hr>

<h1 >Contenido</h1>
<ul class="contenido" >
  <li><a href="#1-introducci%C3%B3n-a-prolog" aria-hidden="true">1. Introducción a Prolog</a></li>
  <ul class="contenido">
    <li><a href="#11-historia" aria-hidden="true">1.1 Historia</a></li>
  </ul>
  <li><a href="#2-sintaxis" aria-hidden="true">2. Sintaxis</a></li>
  <ul class="contenido">
    <li><a href="#21-t%C3%A9rminos" aria-hidden="true">2.1 Términos</a></li>
    <li><a href="#22-programa" aria-hidden="true">2.2 Programa</a></li>
  </ul>
  <li><a href="#3-hechos" aria-hidden="true">3. Hechos</a></li>
  <li><a href="#4-consultas" aria-hidden="true">4. Consultas</a></li>
  <ul class="contenido">
    <li><a href="#41-conjunciones-de-objetivos" aria-hidden="true">4.1 Conjunciones de objetivos</a></li>
  </ul>
  <li><a href="#5-reglas" aria-hidden="true">5. Reglas</a></li>
  <ul class="contenido">
    <li><a href="#51-reglas-recursivas" aria-hidden="true">5.1 Reglas recursivas</a></li>
  </ul>
  <li><a href="#6--backtracking" aria-hidden="true">6.  Backtracking</a></li>
  <li><a href="#7-expresiones" aria-hidden="true">7. Expresiones</a></li>
  <ul class="contenido">
    <li><a href="#71-construcci%C3%B3n-de-expresiones-aritm%C3%A9ticas" aria-hidden="true">7.1 Construcción de expresiones aritméticas</a></li>
    <li><a href="#72-comparaci%C3%B3n-de-t%C3%A9rminos" aria-hidden="true">7.2 Comparación de términos</a></li>
    <li><a href="#73-comparaci%C3%B3n-de-expresiones" aria-hidden="true">7.3 Comparación de expresiones</a></li>
    <li><a href="#74-diferencia-de-expresiones" aria-hidden="true">7.4 Diferencia entre comparación de términos y comparación de expresiones</a></li>
  </ul>
  <li><a href="#8-predicados-predefinidos" aria-hidden="true">8. Predicados predefinidos</a></li>
  <li><a href="#9-listas" aria-hidden="true">9. Listas</a></li>
  <ul class="contenido">
    <li><a href="#91-unificaci%C3%B3n-y-listas" aria-hidden="true">9.1 Unificación y listas</a></li>
    <li><a href="#92-listas-y-recursi%C3%B3n" aria-hidden="true">9.2 Listas y recursión</a></li>
    <li><a href="#93-funciones-predefinidas" aria-hidden="true">9.3 Funciones predefinidas</a></li>
  </ul>
  <li><a href="#10-arboles" aria-hidden="true">10. Arboles</a></li>
  <ul class="contenido">
    <li><a href="#101-representacion2" aria-hidden="true">10.1 Otra representación de arboles </a></li>
      <li><a href="#102-representacion-nario" aria-hidden="true">10.2 Árboles N-arios </a></li>
  </ul>
  <li><a href="#11-ejemplo-grafos" aria-hidden="true">11.Ejemplos en prolog</a></li>
  <ul class="contenido">
    <li><a href="#11-ejemplo-grafos" aria-hidden="true">11.1 Ejemplo Grafos</a></li>
    <ul class="contenido">    
      <li><a href="#11-ejemplo-grafos1" aria-hidden="true">11.1.1 Representación mediante aristas </a></li>
      <li><a href="#11-ejemplo-grafos2" aria-hidden="true">11.1.2 Otras representaciones de grafos </a></li>
    </ul>
    <li><a href="#12-ejemplo-aut%C3%B3matas" aria-hidden="true">11.2 Ejemplo Autómatas</a></li>
    <li><a href="#13-ejemplo-sistema-experto" aria-hidden="true">11.3 Ejemplo Sistema Experto</a></li>
    <li><a href="#14-ejemplo-quick-sort" aria-hidden="true">11.4 Ejemplo QuickSort</a></li>
    <li><a href="#15-ejemplo-compresor" aria-hidden="true">11.5 Ejemplo Compresor</a></li>
    <li><a href="#17-ejemplo-dcg" aria-hidden="true">11.6 Ejemplo DCG</a></li>
    <li><a href="#16-hanoi" aria-hidden="true">11.7 Problema de Torres de Hanoi</a></li>
    <li><a href="#18-ejemplo-bubble" aria-hidden="true">11.8 Ejemplo Bubble Sort</a></li>
    <li><a href="#19-ejemplo-analizador" aria-hidden="true">11.9 Ejemplo Doomie de Analizador Sintáctico del Inglés</a></li>
    <li><a href="#20-ejemplo-sistema-experto-animales" aria-hidden="true">11.10 Ejemplo Sistema Experto Animales</a></li>
  </ul>
  <li><a href="#15-Aplicaciones" aria-hidden="true">12. Aplicaciones</a></li>
  <li><a href="#16-Des-Ven" aria-hidden="true">13. Desventajas / Ventajas</a></li>

</ul>
<h1>
<a id="1-introducción-a-prolog" class="anchor" href="#1-introducci%C3%B3n-a-prolog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. Introducción a Prolog</h1>

<iframe width="560" height="315" src="https://www.youtube.com/embed/5byrm2q5k34" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

      
<p align="justify">Prolog es un lenguaje de programación declarativo que se utiliza para resolver problemas en los que existen objetos y las relaciones entre ellos.  Los lenguajes declarativos se diferencian de los lenguajes imperativos en que están basados en

formalismos abstractos (Prolog tiene sus fundamentos en la lógica de predicados o de primer orden), por lo tanto su semántica no depende de la máquina en la que se ejecutan. Busca obtener conocimiento declarando hechos sobre los objetos y sus relaciones, creando reglas sobre dichos objetos y relaciones y realizando preguntas en ese dominio. Está basado en los siguientes mecanismos básicos: unificación, estructuras de datos basadas en árboles y backtracking.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/fig1.png?raw=true">
</p>

<p align="justify">Antes de comenzar el tutorial es importante  hacer una recomendación. Prolog es diferente a cualquier otro lenguaje de bajo o alto nivel, por tanto, no es recomendable intentar resolver un problema en otro lenguaje para luego traducirlo a Prolog. No hay que buscar un algoritmo que resuelva el problema, sólo es necesario dar las bases para que Prolog lo resuelva.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/06_16_15_MANOSOBRACS5-01.png?raw=true">
</p>

<h2><a id="11-historia" href="11-historia" class="anchor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1.1 Historia</h2>

<p>
  Prolog fue creado en los años 80 en la Universidad de Provenza por Alain Colmerauer y Philippe Roussel.
  Su nombre se deriva del francés <i>programmation en logique</i>.</br>
  Fue diseñado para el procesamiento de lenguaje natural y el razonamiento lógico.
</p>

<p>
  Está basado en la interpretación por procedimientos de Robert Kowalski de las cláusulas de Horn.</br>
  Su desarrollo fue motivado en parte por la idea de reconciliar el uso de la lógica como lenguaje de 
  representación del conocimiento declarativo con la representación procesal del conocimiento que fue 
  popular en los principios de los 70s. La primera implementación de Prolog fue un intérprete escrito 
  en Fortran por Gerard Battani y Henri Meloni.   
</p>

<p>
  Prolog fue preferido por los investigadores de inteligencia artificial europeos, mientras que, 
  los investigadores de IA estadounidenses preferían usar el lenguaje de programación Lisp, lo
  cual abriría un debate que continúa vigente acerca de cuál de los dos lenguajes es mejor en este campo.
</p>

<p>
  Una gran parte del desarrollo moderno en Lisp viene del ímpetu dado por el proyecto para hacer la quinta 
  generación de computadoras cuyo objetivo era el desarrollo de una nueva clase de computadoras que utilizarían 
  técnicas y tecnologías de inteligencia artificial tanto en el plano del hardware como del software y que 
  serían capaces de hacer actividades como la traducción automática entre lenguas naturales.
</p>

<h1>
<a id="2-sintaxis" class="anchor" href="#2-sintaxis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. Sintaxis</h1>

<h2>
<a id="21-términos" class="anchor" href="#21-t%C3%A9rminos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.1 Términos</h2>

<p align="justify">Los términos son el único elemento del lenguaje, un término se compone de un <strong>functor</strong> seguido de cero a N <strong>argumentos</strong> entre paréntesis y separados por comas. </p>

<p align="justify">En Lógica de primer orden, los términos se clasifican en tres categorías: constantes, variables y términos compuestos:</p>

<ul>
<li>
<p><strong>Constantes</strong>:
En Prolog se distinguen dos tipos de constantes:</p>

<ul>
<li>
<p align="justify"><em>Números</em>: Este tipo de constantes se utiliza para representar números enteros y números reales, para poder realizar operaciones aritméticas entre ellos.
Los números enteros se expresan con la notación decimal habitual, ejemplo (0,1,-2124,332,etc).
Los números reales se pueden representar con la notación decimal (ejemplo 1.34, -0.345, etc) o también en notación exponencial (por ejemplo 4.3E6, -0.1e+3, 12.03e-2).</p></li>
<p><img src="images/ej2.png"></p>
<li>
<p align="justify"><em>Atomos o functores</em>: Se utilizan para nombrar objetos, propiedades o relaciones. Deben empezar en minúscula (ejemplo luis, pedro, gato, edad, :-, ?-).</p></li>
<p><img src="images/ej1.png"></p>
</ul>
</li>
<li><p align="justify"><strong>Variables:</strong> Las variables en Prolog se representan mediante cadenas formadas por letras, dígitos y el símbolo
de subrayado,también con una letra mayúscula en su inicio, una excepción es la variable anónima ‘_’. (ejemplo X, Y, Resultado, _nombre, _).</p></li>
<p><img src="images/ej3.png"></p>
<li><p align="justify"><strong>Estructuras:</strong> Son términos compuestos por otros términos. Se construyen mediante un símbolo de función, denominado
<strong>functor</strong> que se define con un átomo, seguido entre paréntesis, por una conjunto de términos separados por comas, denominados argumentos (Ejemplos: fecha(10,mayo,2011), punto(X,Y), recta(punto(11,21), punto(31,25))).
OJO!: Al escribir una estructura, no puede haber ningún espacio entre el functor y el paréntesis abierto antes de los argumentos. Por ejemplo, <em>punto (X,Y)</em> no es una estructura compuesta correcta y generará un error de compilación.</p></li>
<p><img src="images/ej4.png"></p>
</ul>

<h2>
<a id="22-programa" class="anchor" href="#22-programa" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2.2 Programa</h2>

<p align="justify">Los programas en Prolog son programas lógicos definidos, este se basa en un conocimiento base para solucionar consultas así como inferir información y el conocimiento lo representamos mediante cláusulas de Horn positivas. Las cláusulas son hechos o reglas , están compuestas usualmente de predicados. </p>

<p align="justify">La mayoría de los programas Prolog están organizados en cuatro secciones principales:</p>

<ul>
<li>
<strong>Dominio</strong>: donde se declaran los argumentos que utilizarán los predicados.</li>
<li>
<strong>Predicados</strong>: donde se declaran todos los predicados no predefinidos que se utilizarán en las siguientes secciones. </li>
<li>
<strong>Objetivos</strong>: esta sección permite ejecutar los programas de forma no interactiva, y por tanto, buscará la solución deseada tan pronto como se ejecute el programa. Como también es habitual usar Prolog de forma interactiva es frecuente ejecutar un programa y luego esperar a que se nos pregunte por los objetivos.</li>
<li>
<strong>Clausulas</strong>: donde se escriben los hechos y las reglas que conocemos del dominio.</li>
</ul>

<p>Para el desarrollo de este tutorial usaremos la herramienta online de Prolog. <a href="http://swish.swi-prolog.org/">swi Prolog</a></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/prolog2.png?raw=true">
</p>

<p align="justify">Para el caso que se quiera poder trabajar desde la propia máquina se debe realizar los siguiente:</p>
<ul>
<p align="justify"><li><strong>Windows:</strong>Se usa el IDE Swi-Prolog, es el mismo que podemos encontrar online, pero en este caso podemos tenerlo en la máquina local y poder trabajar desde ahí. <a href="http://www.swi-prolog.org/download/stable">Enlace de descarga</a> </li>
</P><li><strong>Linux:</strong> Para poder instalarlo debemos seguir los pasos que encontraremos en el siguiente link <a href="https://wwu-pi.github.io/tutorials/lectures/lsp/010_install_swi_prolog.html">enlace</a>, los comandos que se encontraran allí se deben ejecutar por consola. En este caso no hay un IDE que nos permita correr el codigo con un solo botón,
  si queremos ejecutar código prolog, debemos primero escribir el código con un editor de texto y guardar los archivos con extensión “.pl” . Luego de esto por medio de la consola accedemos a la carpeta donde se encuentran guardados los archivos y estando allí ejecutamos el comando “prolog”,
  esto nos permitirá acceder a la consola de prolog previamente instalada. Ahora para poder ejecutar un programa, debemos poner en consola “ <strong>[ “nombre_archivo.pl” ].</strong> “ ,  luego ya podemos usar las “reglas” que se hayan programado.</li>
</ul>

<h1>
<a id="3-hechos" class="anchor" href="#3-hechos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. Hechos</h1>

<p align="justify">Un hecho es una relación entre objetos. Son el tipo de sentencia más sencillo de Prolog y declaran los valores que son verdaderos para un predicado. No tienen que reflejar el mundo real necesariamente, pero será única y exclusivamente lo que Prolog tomará como verdadero. Están conformados por un predicado y un argumento u objetos como se puede observar en la siguiente imagen. </p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/hechos.png?raw=true">
</p>

<p align="center">
<img src="images/hechos1.png">
</p>

<p align="center">
<img src="images/hechos2.png">
</p>


<p align="justify">Los hechos pueden construir propiedades o relaciones. Cuando están compuestos por un único argumento (monádicos), se dice que es una propiedad. Cuando se forman con dos o más argumentos (poliádicos), construyen relaciones. Existe una serie de reglas que se deben tener presentes al momento de definir un predicado.</p>

<ul>
<li>Los nombres de los hechos (predicado) deben iniciar con minúscula.</li>
<li>Los argumentos se escriben separados por comas, en minúscula y encerrados entre paréntesis.</li>
<li>Todos los hechos deben terminar en punto.</li>
</ul>

<p>Un ejemplo de un hecho es:</p>

<pre><code>     persona(juan,27).
</code></pre>

<h2>
<a id="ejemplo-práctico" class="anchor" href="#ejemplo-pr%C3%A1ctico" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ejemplo práctico</h2>

<p align="justify">Para entender un poco mejor la función de los hechos en Prolog,iniciaremos con un primer ejemplo. Observe el siguiente árbol genealógico. </p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol.png?raw=true"></p>

<p align="justify">Podemos observar que el tipo de hechos que se presentan en la imagen son relaciones. Tenemos la relación entre dos personas, esta relación podremos llamarla progenitor. Por tanto los hechos que describen el árbol de la imagen quedan definidos como:</p>

<pre><code>     progenitor(clara,jose).        %Hecho 1
     progenitor(tomas, jose).       %Hecho 2
     progenitor(tomas,isabel).      %Hecho 3
     progenitor(jose, ana).         %Hecho 4
     progenitor(jose, patricia).    %Hecho 5
     progenitor(patricia,jaime).    %Hecho 6
</code></pre>

<p> Otro ejemplo de familias</p>

<p align="center">
<img src="images/hechos-familias-padre.png">
</p>
<br/>

<p align="center">
<img src="images/hechos-familias-madre.png">
</p>

<p>Reglas para poder hallar relación familiar.</p>

<p align="center">
<img src="images/reglas-familias-1.png">
</p>
<br/>

<p align="center">
<img src="images/reglas-familias-2.png">
</p>


<h1>
<a id="4-consultas" class="anchor" href="#4-consultas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. Consultas</h1>

<p align="justify">Sobre un conjunto de hechos se pueden definir realizar una serie de preguntas para extraer conocimiento de la base de datos generada por los hechos. Comienzan con un signo de interrogación seguido de un guión <strong>?-</strong> y terminan en punto.
Ante una consulta, Prolog intenta hacer un <em>matching</em> sobre la base de conocimiento. </p>

<p align="justify">Cuando en una consulta se tiene más de una alternativa Prolog devuelve la primera ocurrencia, se obtienen las demás insertando el token punto y coma. Las respuestas a una consulta puede ser <strong>true</strong>, <strong>false</strong> o los elementos que pueden tomar una variable definida. Un ejemplo simple de una consulta puede ser:</p>

<pre><code>     ?-progenitor(patricia,jaime).
</code></pre>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta1.png?raw=true"></p>

<p>Se puede observar que la respuesta a la pregunta fue <strong>true</strong>, ya que la consulta pudo ser unificada con el Hecho 6 de la base de conocimiento.</p>

<h3>
<a id="variables" class="anchor" href="#variables" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Variables</h3>

<p align="justify">Para realizar consultas más interesantes se puede hacer el uso de variables. Es importante recordar que las variables deben iniciar con letra mayúscula o con el carácter (<strong>_</strong>). Existe una variable especial, la variable anónima o blanca. Esta variable se utiliza de la misma manera que las demás variables pero nunca toma ningún valor. </p>

<h2>
<a id="41-conjunciones-de-objetivos" class="anchor" href="#41-conjunciones-de-objetivos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4.1 Conjunciones de objetivos</h2>

<p>Se usan para resolver preguntas complejas que requieren varios hechos. Están compuestas por dos o más objetivos separados por una coma y finalizan en punto. </p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta2.png?raw=true"></p>

<h2>
<a id="ejemplo-práctico-1" class="anchor" href="#ejemplo-pr%C3%A1ctico-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ejemplo práctico</h2>

<p align="justify">Siguiendo con el ejemplo del árbol genealógico definido anteriormente, vamos a responder las siguientes preguntas:</p>

<ul>
<li>
<p>a). ¿Qué arroja la siguiente consulta?: <code>?-progenitor(jaime,X).</code> </p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta4.png?raw=true"></p>

<p align="justify">Como se puede observar la respuesta es <strong>false</strong> ya que no existe en la base de conocimiento un hecho para el cual jaime sea progenitor de alguien. Esto se puede verificar en el árbol genealógico.</p>
</li>
<li>
<p>b). ¿Qué arroja la siguiente consulta?: <code>?-progenitor(X,jaime).</code></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta5.png?raw=true"></p>

<p>Esta consulta arroja todos los progenitores de jaime. Según el árbol genealógico de la figura y los hechos definidos para el árbol, la única progenitora de jaime es patricia.</p>
</li>
<li>
<p>c). ¿Qué arroja la siguiente consulta?: <code>?-progenitor(tomas,X), progenitor(X,Y),progenitor(Y,Z).</code></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta6.png?raw=true"></p>

<p align="justify">Arroja la información de los bisnietos de tomas, con su respectivos padres y abuelos. En este caso sólo tenemos una opción para X,Y,Z ya que sólo existe un bisnieto para tomas que es jaime.</p>
</li>
<li>
<p align="justify">d). Defina una consulta que permita determinar si clara es bisabuela de jaime.
Teniendo en cuenta la consulta del punto c). podemos usarlo como referencia. Necesitamos construir un árbol con 3 niveles de profundidad,uno para la relación de bisabuelo y abuelo, otro para la relación de abuelo y padre y finalmente el nivel de la relación de padre e hijo. Sabemos que la bisabuela es clara y el bisnieto es jaime, por tanto existen dos variables que no conocemos: el abuelo y el padre. Podemos definir X= abuelo, Y= padre. La consulta quedaría como se muestra a continuación.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/pregunta3.png?raw=true"></p>

<p align="justify">Si clara no fuera bisabuela de jaime, la consulta arrojaría false, pero Prolog logró unificar la consulta con dos hechos:
<code>?-progenitor(tomas,jose)</code>, <code>?-progenitor(jose,patricia).</code> y <code>?-progenitor(patricia,jaime).</code> Por lo tanto X= jose y Y= patricia.</p>
</li>
</ul>

<h1>
<a id="5-reglas" class="anchor" href="#5-reglas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. Reglas</h1>

<p align="justify">Cuando la verdad de un hecho depende de la verdad de otro hecho o de un grupo de hechos se usa una regla. Declaran las condiciones para que un predicado sea cierto, con una implicación que pueden relacionar hechos para dar los valores de verdad a un predicado (la cabeza se cumple si el cuerpo se cumple). Funcionan como las fórmulas condicionales habituales en lógica. Una regla está compuesta por una cabeza y una cuerpo. El cuerpo puede estar formado por varios hechos y objetivos.
Su sintaxis general es:</p>

<p><strong><p align="center"> cabeza :- objetivo1, objetivo2, ..., objetivon.</p></strong></p>

<p>Formalmente, desde un punto de vista lógico, se interpretaría de la siguiente forma:
<em><p align="center"> objetivo1 ∧ ⋯ ∧ objetivon → cabeza</p></em></p>

<p>Los objetivos van separados por comas, especificando conjunción y al final debe de ir un punto. Por ejemplo:</p>

<pre><code>            animal_carnívoro( X ):- animal( X ), carnívoro( X ).
</code></pre>

<p>Existen dos tipos de reglas:</p>

<ul>
<li>
<p><strong>Conjunciones</strong></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/conjuncion.png?raw=true"></p>
</li>
<li>
<p><strong>Disyunciones</strong></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/disyuncion.png?raw=true"></p>
</li>
</ul>

<h2>
<a id="51-reglas-recursivas" class="anchor" href="#51-reglas-recursivas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5.1 Reglas recursivas</h2>

<p align="justify">Con la definición del tipo de reglas simple se pueden resolver diferentes problemas, sin embargo, la gran potencia de Prolog está en la definición de reglas recursivas. Siguiendo con el ejemplo del árbol genealógico,se puede definir relaciones para el abuelo, bisabuelo, tatarabuelo, etc. Podría ser interesante definir la relación predecesor(X,Y). Un predecesor de X podrá ser el progenitor de X. También será predecesor si es abuelo/a, si es tatarabuelo/a, etc., es decir, podríamos definir un conjunto de reglas como:</p>

<pre><code>     predecesor(X,Y):-progenitor(X,Y).                                   %padre
     predecesor(X,Y):-progenitor(X,Z), progenitor(Z,Y).                  %abuelo
     predecesor(X,Y):-progenitor(X,Z), progenitor(Z,V), progenitor(V,Y). %bisabuelo
</code></pre>

<p align="justify">Resulta engorroso tener que definir una nueva regla para cada vínculo con un predecesor, ¿qué pasaría si queremos conocer a un predecesor 10 niveles atrás en el árbol genealógico?, ¿necesitaremos definir 10 reglas diferentes?. No. Podemos hacer uso de las reglas recursivas.</p>

<p>Para hacer uso de reglas recursivas se debe considerar 2 casos:</p>

<ul>
<li>
<strong>Caso básico:</strong> Define cuándo se detiene el cálculo.</li>
<li>
<strong>Caso recursivo:</strong> Suponiendo que ya se ha solucionado un caso más simple, define cómo descomponer el caso actual hasta llegar al caso básico.</li>
</ul>

<p>Reescribiendo la relación predecesor de forma recursiva quedaría:</p>

<pre><code>     predecesor(X,Y):-progenitor(X,Y).                    %caso base
     predecesor(X,Y):-progenitor(X,Z), predecesor(Z,Y).   %caso recursivo
</code></pre>

<h2>
<a id="ejemplo-práctico-2" class="anchor" href="#ejemplo-pr%C3%A1ctico-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ejemplo práctico.</h2>

<p>Siguiendo con el árbol genealógico que hemos venido trabajando, resolver:</p>

<ul>
<li>a). Defina las reglas y consultas para encontrar a la madre y el padre de un elemento o todos los elementos del árbol.
Los padres son progenitores, lo único que cambia entre el padre y la madre es el sexo. Por eso es necesario definir nuevos hechos para representar el sexo de cada persona en el árbol.
<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/madrepadre.png?raw=true"></p>
Con la siguiente consulta podemos consultar quién es madre de quién. X= madre, Y=hijo.
<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/madre.png?raw=true"></p>
Las filas de la tabla de resultados son las relaciones que se forman según el árbol.</li>
<li>clara es madre de jose</li>
<li>patricia es madre de jaime
De la misma forma podemos consultar los padres y sus hijos en el árbol.
<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/padre.png?raw=true"></p>
Como se puede observar en la tabla anterior, se obtie el resultado de todas las parejas que se pueden formar entre padres e hijos según el árbol genealógico.</li>
<li>tomas es padre de jose</li>
<li>tomás es padre de isabel</li>
<li>jose es padre de ana</li>
<li><p>jose es padre de patricia</p></li>
<li>
<p>b). Defina las reglas y consultas para encontrar un abuelo.
Sabemos que un abuelo tiene dos niveles de relación con un nieto: <code>progenitor(Abuelo,Padre).</code> y <code>progenitor(Padre,Nieto).</code>
Por tanto podemos definir la siguiente relación:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/abuelo.png?raw=true"></p>
</li>
<li>
<p>c). Defina las reglas y consultas para encontrar los antepasados usando reglas recursivas.
Para determinar un antepasado de forma recursiva necesitamos dos casos: El caso base y el caso recursivo. Por tanto la regla queda definida de la siguiente forma:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/antepasado.png?raw=true"></p>
</li>
</ul>

<h1>
<a id="6--backtracking" class="anchor" href="#6--backtracking" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.  Backtracking</h1>

<p align="justify"> Prolog siempre está consultando “la base del conocimiento”, para verificar que hechos son verdaderos y que nos permitirá la construcción de las posibles reglas. Para aquello en problemas de recursión, prolog se devuelve hasta que encuentra que un hecho base es verdadero y de ahí construye la respuesta.</p>

<p align="justify">En el siguiente ejemplo podemos ver que si consultamos K(Y), donde Y puede ser “a” o “b”. En este caso prolog va ir a lo más profundo del árbol en busca de los “hechos” , para ver como establecimos la base del conocimiento. Así se puede ver que h(a), da error dado a que no se encuentra en los hechos y en cambio retorna h(b) hasta K(Y)  y por último Y tomaría el valor de “b”.</p>

<p align="center">
<img src="images/backtrack1.png">
</p>

<p> Ejemplo práctico de cómo hallar el factorial de un número .</p>
<p align="center">
<img src="images/factorial.png">
</p>

<p> Ejemplo práctico - fibonacci .</p>
<p align="center">
<img src="images/fibo.png">
</p>


<p>Considerando el siguiente ejemplo, vamos a entender cómo hace Prolog para verificar cuándo se cumple una regla.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/recursiva.png?raw=true"></p>

<p>Prolog intenta satisfacer los objetivos de la consulta de izquierda a derecha y para
cada uno va probando las cláusulas correspondientes.</p>

<h3>
<a id="primer-intento" class="anchor" href="#primer-intento" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Primer intento</h3>

<p>Prolog trabaja analizando los objetivos de izquierda a derecha los objetivos de la regla. Y verificando los hechos de arriba hacia abajo.
El primer objetivo que intentará analizar es <code>sevende(Y).</code></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol1.png?raw=true"></p>

<p>Como el orden en que se definan los hechos importa, el primer hecho que encuentra en la base de conocimiento es <code>sevende(vestido).</code> Así que la variable Y queda instanciada como vestido.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol2.png?raw=true"></p>

<p>Ahora debe verificar para cuales hechos se cumple que <code>gusta(X,vestido).</code></p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol3.png?raw=true"></p>

<p>Como se puede observar en la imagen, la X queda instanciada como maria porque es el primer hecho para el cual se cumple el objetivo.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol4.png?raw=true"></p>

<p align="justify">Finalmente debe verificar el último objetivo <code>bueno(vestido).</code>. Este objetivo no está definido en la base de conocimiento por tanto este camino en el árbol se rechaza porque ha seleccionado una cláusula que no conduce a la solución. Por esta razón es necesario aplicar un retroceso <strong>backtracking</strong>.</p>

<h3>
<a id="segundo-intento" class="anchor" href="#segundo-intento" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Segundo intento</h3>

<p align="justify">Prolog se devuelve hasta el punto donde instanció Y= vestido. Y busca el siguiente hecho que pueda unificar con  <code>sevende(X).</code> obteniendo como resultado X= sombrero. Se repiten los demás pasos, llegando finalmente al hecho <code>sevende(sombrero).</code> como una verdad, por tanto el camino se acepta obteniendo una posibilidad a la regla con Y= sombrero y X= maria.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbol5.png?raw=true"></p>

<h1>
<a id="7-expresiones" class="anchor" href="#7-expresiones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7. Expresiones</h1>

<h2>
<a id="71-construcción-de-expresiones-aritméticas" class="anchor" href="#71-construcci%C3%B3n-de-expresiones-aritm%C3%A9ticas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.1 Construcción de expresiones aritméticas</h2>

<p align="justify">Prolog tiene predefinidos los operadores aritméticos más habituales, mediante los que se pueden formar expresiones aritméticas. A continuación se enumeran algunos de los más importantes:</p>

<table>
<thead>
<tr>
<th>Expresión</th>
<th>Operación</th>
</tr>
</thead>
<tbody>
<tr>
<td>X+Y</td>
<td>suma de X e Y</td>
</tr>
<tr>
<td>X-Y</td>
<td>X menos Y</td>
</tr>
<tr>
<td>X*Y</td>
<td>producto de X por Y</td>
</tr>
<tr>
<td>X/Y</td>
<td>cociente real de la división de X por Y</td>
</tr>
<tr>
<td>X//Y</td>
<td>cociente entero de la división de X por Y</td>
</tr>
<tr>
<td>X^Y</td>
<td>potencia entera de X a la Y</td>
</tr>
<tr>
<td>X**Y</td>
<td>potencia real de X a la Y</td>
</tr>
<tr>
<td>X mod Y</td>
<td>resto de la división entera de X por Y</td>
</tr>
<tr>
<td>abs(X)</td>
<td>valor absoluto de X</td>
</tr>
<tr>
<tr>
<td>acos(X)</td>
<td>arco coseno de X</td>
</tr>
<tr>
<td>asen(X)</td>
<td>arco seno de X</td>
</tr>
<tr>
<td>atan(X)</td>
<td>arco tangente de X</td>
</tr>
<tr>
<td>cos(X)</td>
<td>coseno de X</td>
</tr>
<tr>
<td>exp(X)</td>
<td>exponencial de X; [eX]</td>
</tr>
<tr>
<td>ln(X)</td>
<td>logaritmo neperiano de X</td>
</tr>
<tr>
<td>log(X)</td>
<td>logaritmo en base 2 de X</td>
</tr>
<tr>
<td>sin(X)</td>
<td>seno de X</td>
</tr>
<tr>
<td>sqrt(X)</td>
<td>raíz cuadrada de X</td>
</tr>
<tr>
<td>tan(X)</td>
<td>tangente de X</td>
</tr>
<tr>
<td>round(X,N)</td>
<td>redondeo del real X con N decimales</td>
</tr>
</tbody>
</table>

<p align="justify">Es importante tener en cuenta que los operadores anteriores sólo permiten construir expresiones aritméticas, pero estas  son estructuras (términos compuestos) que no representan ningún valor. Por ejemplo, la expresión 13+5 no es otra cosa  que el término compuesto +(3,5) escrito en <em>notación infija</em>. No se pueden realizar consultas del estilo “ ?- 13+5.”, porque “+” no es un predicado.
¿Qué pasa si hacemos la consulta “ ?- 13+5 = 8.”? </p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/consulta.png?raw=true"></p>

<p align="justify">Como se puede observar a pesar de que al realizar la operación 13+5 obtenemos como resultado 18, para Prolog esto es falso dado que el término compuesto +(3,5) no es unificable con el término constante 8. Para poder evaluar expresiones aritméticas en Prolog hay que utilizar los predicados aritméticos que se describen a continuación.</p>

<h2>
<a id="72-comparación-de-términos" class="anchor" href="#72-comparaci%C3%B3n-de-t%C3%A9rminos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.2 Comparación de términos</h2>

<p  >Los siguientes operadores son los que permiten comparar términos en Prolog.</p>

<table>
<thead>
<tr>
<th>Expresión</th>
<th>Operación</th>
</tr>
</thead>
<tbody>
<tr>
<td>X&lt;Y</td>
<td>cierto si el valor numérico de X es menor que el de Y</td>
</tr>
<tr>
<td>X&gt;Y</td>
<td>cierto si el valor numérico de X es mayor que el de Y</td>
</tr>
<tr>
<td>X=&lt;Y</td>
<td>cierto si el valor numérico de X es menor o igual que el de Y</td>
</tr>
<tr>
<td>X&gt;=Y</td>
<td>cierto si el valor numérico de X es mayor o igual que el de Y</td>
</tr>
</tbody>
</table>

<h2>
<a id="73-comparación-de-expresiones" class="anchor" href="#73-comparaci%C3%B3n-de-expresiones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.3 Comparación de expresiones</h2>

<p align="justify">Los siguientes predicados predefinidos comparan expresiones sin evaluarlas, mediante una comparación sintáctica siguiendo el siguiente orden:</p>

<ul>
<li>variables,</li>
<li>enteros y reales,</li>
<li>átomos en orden alfabético,</li>
<li>términos complejos: aridad, nombre y orden según la definición recursiva.</li>
</ul>

<table>
<thead>
<tr>
<th>Expresión</th>
<th>Operación</th>
</tr>
</thead>
<tbody>
<tr>
<td>X==Y</td>
<td>la expresión X es igual que la expresión Y</td>
</tr>
<tr>
<td>X\==Y</td>
<td>la expresión X es distinta que la expresión Y</td>
</tr>
<tr>
<td>X@&lt;Y</td>
<td>la expresión X es menor que la expresión Y</td>
</tr>
<tr>
<td>X@&gt;Y</td>
<td>la expresión X es mayor que la expresión Y</td>
</tr>
<tr>
<td>X@=&lt;Y</td>
<td>la expresión X es menor o igual que la expresión Y</td>
</tr>
<tr>
<td>X@&gt;=Y</td>
<td>la expresión X es mayor o igual que la expresión Y</td>
</tr>
<tr>
<td>X is Y</td>
<td>Si Y es una expresión aritmética, ésta se evalúa y el resultado se intenta unificar con X.</td>
</tr>
</tbody>
</table>

<p>Ejemplo:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/aritmetico.png?raw=true"></p>

<p>Cuando se quiere comparar expresiones(ej:predicados, términos complejos) se añade un @ inmediatamente después de la primera expresión (X @< Y)</p>

<p align="center">
<img src="images/@eg.png">
</p>

<p>Algunos ejemplos del uso de expresiones:</p>
<p><img src="images/expr.png"></p>

<p align="justify">Los siguientes predicados predefinidos comparan términos haciendo una evaluación
de expresiones:</p>

<table>
<thead>
<tr>
<th>Expresión</th>
<th>Operación</th>
</tr>
</thead>
<tbody>
<tr>
<td>X =:= Y</td>
<td>cierto si los valores numéricos de X e Y son iguales</td>
</tr>
<tr>
<td>X =\= Y</td>
<td>cierto si los valores numéricos de X e Y son distintos</td>
</tr>
</tbody>
</table>

<h2>
  <a id="74-diferencia-de-expresiones" class="anchor" href="#74-diferencia-de-expresiones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7.4 Diferencia entre comparación de términos y comparación de expresiones
</h2>

<p align="justify">En Prolog, los operadores de comparación de expresiones y de términos también son llamados comparadores sintácticos y semánticos respectivamente, 
  estos son conceptos fundamentales que se utilizan para comparar y relacionar términos y estructuras de datos en este lenguaje de programación lógica. 
  Estos operadores desempeñan un papel crucial en la formulación de reglas lógicas y consultas, lo que permite a los programadores expresar y resolver 
  problemas de manera declarativa. A continuación, profundizaremos en la diferencia entre los operadores sintácticos y semánticos, y cómo influyen en la
  programación en Prolog.</p>
<h3>Operadores Semánticos</h3>
<p align="justify">Por otro lado, los operadores semánticos se enfocan en la comparación de términos y estructuras de datos en función de su significado o contenido. 
  La igualdad semántica implica que dos términos o estructuras son iguales si representan la misma entidad o valor, independientemente de cómo se expresan 
  en el código fuente. </p>
<h3>Operadores Sintácticos</h3>
<p align="justify">Los operadores sintácticos se centran en la comparación de términos y estructuras de datos en función de su representación literal en el código fuente.
   La igualdad sintáctica implica que dos términos o estructuras deben ser idénticos en su forma, notación y estructura para considerarse iguales. </p>
<h3>Diferencias Clave</h3>
<h4>Representación vs. Significado</h4>
<p align="justify">La principal diferencia entre los operadores sintácticos y semánticos radica en si se comparan los términos en función de su representación literal 
  (sintaxis) o su significado (semántica).</p>

<h4>Flexibilidad Semántica</h4>
<p align="justify">Los operadores semánticos son más flexibles en términos de cómo se pueden expresar los términos. Dos términos que 
representan la misma entidad, pero se han escrito de manera diferente, son iguales desde una perspectiva semántica.</p>

<h4>Evaluación de Igualdad</h4>
<p align="justify">La igualdad sintáctica requiere que los términos sean idénticos en su forma literal, mientras que la igualdad semántica se 
  basa en si representan la misma entidad o valor.</p>


<h1>
<a id="8-predicados-predefinidos" class="anchor" href="#8-predicados-predefinidos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>8. Predicados predefinidos</h1>

<p>Los predicados predefinidos son aquellos que ya están definidos en PROLOG, es decir, no necesitamos especificarlos mediante cláusulas. Existen dos tipos de predicados predefinidos:</p>

<ul>
<li>Aquellos predicados de uso frecuente que ya los proporciona PROLOG, aunque podríamos definirlos nosotros.</li>
<li>Predicados con un efecto colateral distinto a la instanciación de variables a valores (funcionamiento normal del PROLOG).</li>
</ul>

<p>Este conjunto de predicados permiten determinar el tipo de términos que estamos usando.</p>

<table>
<thead>
<tr>
<th>Predicado</th>
<th>Función</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td>El objetivo var(X) se cumple si X es una variable no instanciada.</td>
</tr>
<tr>
<td>nonvar</td>
<td>El objetivo nonvar(X) se cumple si X es una variable instanciada</td>
</tr>
<tr>
<td>atom</td>
<td>El objetivo atom(X) se cumple si X representa un átomo.</td>
</tr>
<tr>
<td>integer</td>
<td>El objetivo integer(X) se cumple si X representa un número entero.</td>
</tr>
<tr>
<td>atomic</td>
<td>El objetivo atomic(X) se cumple si X representa un entero o un átomo.</td>
</tr>
</tbody>
</table>

<p>Los siguientes son predicados predefinidos que permiten controlar otros predicados.</p>

<table>
<thead>
<tr>
<th>Predicado</th>
<th>Función</th>
</tr>
</thead>
<tbody>
<tr>
<td>!(cut)</td>
<td>Fuerza al sistema a mantener ciertas elecciones que ha realizado.</td>
</tr>
<tr>
<td>true</td>
<td>Este objetivo siempre se cumple.</td>
</tr>
<tr>
<td>fail</td>
<td>Este objetivo siempre fracasa.</td>
</tr>
<tr>
<td>not</td>
<td>El objetivo not(X) se cumple si fracasa el intento de satisfacer X. El objetivo not(X) fracasa si el intento de satisfacer X tiene éxito. Es similar a la negación en la lógica de predicados.</td>
</tr>
<tr>
<td>repeat</td>
<td>forma auxiliar para generar soluciones múltiples mediante el mecanismo de reevaluación.</td>
</tr>
<tr>
<td>call</td>
<td>Se cumple si tiene éxito el intento de satisfacer X.</td>
</tr>
<tr>
<td>;</td>
<td>Especifica una disyunción de objetivos</td>
</tr>
<tr>
<td>,</td>
<td>Especifica una conjunción de objetivos</td>
</tr>
</tbody>
</table>

<p>Predicados de lectura y escritura</p>

<table>
<thead>
<tr>
<th>Predicado</th>
<th>Función</th>
</tr>
</thead>
<tbody>
<tr>
<td>write</td>
<td>escribe el término X en la consola de salida.</td>
</tr>
<tr>
<td>nl</td>
<td>genera una nueva línea en la consola de salida.</td>
</tr>
<tr>
<td>read</td>
<td>lee el siguiente término en la consola de entrada.</td>
</tr>
<tr>
<td>display</td>
<td>funciona exactamente igual que write, excepto que <br> pasa por alto las declaraciones de operadores.</p></td>
</tr>
</tbody>
</table>

<p> Predicados para modificacion de la base de conocimiento. </p>
<p> <b>Los hechos de la base de conocimiento que se deseen cambiar, deben ser marcados como dinámicos antes de usarse. </b></p>
<table>
  <thead>
  <tr>
  <th>Predicado</th>
  <th>Función</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>assertz</td>
  <td>Inserta un hecho al final de la lista de hechos de un predicado.</td>
  </tr>
  <tr>
  <td>asserta</td>
  <td>Inserta un hecho al inicio de la lista de hechos de un predicado.</td>
  </tr>
  <tr>
  <td>retract</td>
  <td>Remueve un hecho de la base de conocimiento.</td>
  </tr>
  <tr>
  <td>retractall</td>
  <td>Remueve todos los hechos que coincidan con el argumento recibido.</td>
  </tr>
  </tbody>
  </table>
  <p> Algunos ejemplos: </p>
  <p align="center">
    <img src="images/ejemplosMBC.png">
  </p>

<h1>
<a id="9-listas" class="anchor" href="#9-listas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9. Listas</h1>

<p align="justify">Una lista es una tipo concreto de estructura de datos simple. Es una secuencia ordenada de elementos que puede tener cualquier longitud. Un elemento puede ser cualquier tipo de dato e incluso otra lista.  En Prolog las listas están formadas por cabeza y cola.  Se representan como una serie de elementos separados por comas y encerrados entre corchetes. Por ejemplo en la lista:</p>

<p align="center">
    <img height="300" src="images/imagenListas2.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <img height="300" src="images/imagenListas1.png">
    <br>Notación de predicado para listas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notación de corchetes cuadrados.
</p>
<pre><code>     [a, b, c, d]
</code></pre>

<p>Se tiene que <strong>a</strong> es la cabeza de la lista y [b, c, d] la cola.</p>

<table>
<thead>
<tr>
<th>Lista</th>
<th>Cabeza</th>
<th>Cola</th>
</tr>
</thead>
<tbody>
<tr>
<td>[a,b,c,d]</td>
<td>a</td>
<td>[b,c,d]</td>
</tr>
<tr>
<td>[a]</td>
<td>a</td>
<td>[]</td>
</tr>
<tr>
<td>[]</td>
<td>no tiene</td>
<td>no tiene</td>
</tr>
<tr>
<td>[[a,b],c]</td>
<td>[a,b]</td>
<td>[c]</td>
</tr>
<tr>
<td>[a,[b,c]]</td>
<td>a</td>
<td>[[b,c]]</td>
</tr>
<tr>
<td>[a,b,[c,d]]</td>
<td>a</td>
<td>[b,[c,d]]</td>
</tr>
</tbody>
</table>

<p>Una lista cuya cabeza es A y la cola es B, en prolog se denota como:</p>

<pre><code>     [A | B]
</code></pre>

<h2>
<a id="91-unificación-y-listas" class="anchor" href="#91-unificaci%C3%B3n-y-listas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9.1 Unificación y listas</h2>

<p>En Prolog se puede unificar una lista con otra.</p>

<pre><code>     [X,Y,Z]= [a,b,c]
     X = a
     Y = b
     Z = c
</code></pre>

<p>Una variable que no está instanciada se puede unificar con cualquier objeto, por tanto se puede unificar una lista con una variable.</p>

<pre><code>     X= [a,b,c]
</code></pre>

<p>Para unificar una variable con una lista pero separando su cabeza y cola se debe hacer de la forma  [A | B] donde el símbolo (|) separará la cabeza de la cola. Ejemplo:</p>

<pre><code>     [a,b,c] = [Cabeza|Cola]
     Cabeza = a
     Cola = [b,c]


     [a,b,c] = [X,Y|Z]
     X = a
     Y = b
     Z = [c]

     [a,b,c] = [X,Y,Z|Cola]
     X = a
     Y = b
     Z = c
     Cola = [ ]
</code></pre>

<h2>
<a id="92-listas-y-recursión" class="anchor" href="#92-listas-y-recursi%C3%B3n" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9.2 Listas y recursión</h2>

<p>En Prolog existen tres criterios de terminación importantes:</p>

<ul>
<li>
<p>Cuando la lista es vacía.
El esquema general es:</p>

<pre><code> /* Regla de terminacion */
 predicado([ ]):- procesar([ ]).
 /* Regla recursiva */
 predicado([Cabeza | Cola]):- procesar(Cabeza), predicado(Cola).
</code></pre>
</li>
<li>
<p>Cuando un elemento es encontrado.
El esquema general es:</p>

<pre><code> /* Regla de terminación */
 predicado(Cabeza, [Cabeza | Cola]):- procesar algo.
 /* Regla recursiva */
 predicado(X, [Cabeza | Cola]):- procesar algo, predicado(X, Cola).
</code></pre>
</li>
<li>
<p>Cuando una posición es encontrada.
El esquema general es:</p>

<pre><code> /* Regla de terminacion */
 predicado(1,Cabeza, [Cabeza | Cola]):- procesar algo.
 /* Regla recursiva */
 predicado(P, X, [ | L]):- P1=P-1, predicado(P1,X, L).
</code></pre>
</li>
</ul>

<h3>
<a id="ejemplos-prácticos" class="anchor" href="#ejemplos-pr%C3%A1cticos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ejemplos prácticos:</h3>

<ul>
<li><p>a). Encontrar el último elemento de una lista.
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista1.png?raw=true"></p></li>
<li><p>b). Encontrar el k-ésimo elemento de una lista.
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista2.png?raw=true"></p></li>
<li><p>c). Calcular la longitud de la lista.
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista4.png?raw=true"></p></li>
<li><p>d). Verifica si una lista es palíndroma o no.
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista5.png?raw=true"></p></li>
<li><p>e). Crear una lista que contenga los enteros de un rango dado.
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista6.png?raw=true"></p></li>
<li><p>f). Sumar los elementos de una lista
<img src="https://github.com/mppinedav/prologtutorial/blob/master/lista7.png?raw=true"></p></li>
<li><p>g.)Reglas basicas aplicadas a las listas. <img src="images/final-lista.png"></p></li>
<li><p>i.) Algoritmo para ordenar una lista usando Merge Sort. <img src="images/merge-sort.png"></p></li>
</ul>

<h2>
<a id="93-funciones-predefinidas" class="anchor" href="#93-funciones-predefinidas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>9.3 Funciones predefinidas</h2>
<ul>
<li><strong>Is_list: </strong>Determina si un término es lista</li>
<li><strong>Member: </strong>Esta función es muy útil para “iterar” sobre la lista así como revisar si un item pertence a la lista.
<p align="center">
<img src="images/member.png">
</p>
</li>
<li><strong>Length: </strong>Permite obtener la longitud de una lista</li>
<li><strong>Append: </strong>Permite concatenar dos listas, obtener sublistas y generar todas las combinaciones de listas
<p align="center">
<img src="images/append.png">
</p>
</li>
<li>
    <strong>Sort: </strong>Permite ordenar una lista
    
</li>
</ul>


<h1>
<a id="10-arboles" class="anchor" href="#10-arboles" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10. Arboles</h1>

<p align="justify">Un árbol binario es una estructura que contiene un nodo padre y dos nodos hijos; uno izquierdo y uno derecho. Se puede decir que un árbol es una estructura con una definición puramente recursiva, ya que se puede definir como el elemento raíz cuyos hijos son a su vez árboles. </p>

<h4>
<a id="representación-en-prolog-de-árboles" class="anchor" href="#representaci%C3%B3n-en-prolog-de-%C3%A1rboles" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Representación en Prolog de árboles</h4>

<p>Como un árbol es una estructura recursiva, necesitaremos un caso base y un caso recursivo. </p>

<ul>
<li>X es un árbol vacío</li>
<li>
<p>X es un árbol con hijos</p>

<pre><code> binary_tree(void).                       %caso base
 binary_tree(t(K,L,R)) :-                 %caso recursivo
                         binary_tree(L),
                         binary_tree(R).
</code></pre>
</li>
</ul>

<p>Como se puede observar se necesitan 3 elementos para definir un árbol: la raíz, el subárbol izquierdo y el subárbol derecho. Veamos un ejemplo:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/tree1.png?raw=true"></p>

<p>El árbol de la imagen en la relación t(K,L,R) queda definido como:</p>

<pre><code>     tree1(t(6, t(4, t(2, nil, nil), t(5, nil, nil)), t(9, t(7, nil, nil), nil))).
</code></pre>

<p>También podemos definir reglas para realizar los posibles recorridos en el árbol:</p>

<ul>
<li>
<p><strong>Inorder:</strong></p>

<pre><code> inorder(nil, []).
 inorder(t(K,L,R), List):-inorder(L,LL),
                          inorder(R, LR),
                          append(LL, [K|LR],List).
</code></pre>
</li>
<li>
<p><strong>Preorder:</strong></p>

<pre><code> preorder(nil, []).
 preorder(t(K,L,R), List):-preorder(L,LL),
                           preorder(R, LR),
                           append([K|LL], LR, List).
</code></pre>
</li>
<li>
<p><strong>Postorder:</strong></p>

<pre><code> postorder(nil, []).
 postorder(t(K,L,R), List):-postorder(L,LL),
                            postorder(R, LR),
                            append(LL, LR,R1),
                            append(R1, [K], List).
</code></pre>
</li>
</ul>

<p>Al realizar las pruebas con el árbol del ejemplo y los diferentes recorridos obtenemos como resultado:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/arbolrecorrido.png?raw=true"></p>

<h2>
<a id="101-representacion2" class="anchor" href="#101-representacion2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10.1 Otra representación de arboles </h2>

<p align="center">
<img src="images/arbol1.png">
</p>

<br/>
<p align="center">
<img src="images/arbol2.png">
</p>

<br/>
<p align="center">
<img src="images/Arbol-ejemplo.png">
</p>

<h2>
    <a id="102-representacion-nario" class="anchor" href="#102-representacion-nario" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10.2 Árboles N-arios
</h2>

<p>
    Para definir un árbol n-ario, empleamos listas, en las cuales la cabeza será el nodo padre y todos los elementos de la cola serán el conjunto de nodos hijos.
    <br/><br/>Entonces, si tenemos: <pre><code>mi_arbol_n_ario([7, [0.9], [15], [[42, ar]], [3.333]])</code></pre>
    Corresponderá al siguientre árbol:
</p>
<p align="center">    
    <img src="images/arbol-n-ario.png">
</p>
<p>
    Para verificar que una estructura sí es lista
    
<pre><code>es_arbol_n_ario([]).
es_arbol_n_ario([_ | Hijos]) :- iterar_hijos(Hijos).

iterar_hijos([]).
iterar_hijos([Hijo | Lista]) :- es_arbol_n_ario(Hijo), iterar_hijos(Lista).</code></pre>

Implementación de recorrido preorder.<br><br>
<pre><code>preorder([], []).
preorder([Padre | Hijos], Lista) :- iterar_preorder(Hijos, L),
        append([Padre], L, Lista).

iterar_preorder([], []).
iterar_preorder([Hijo | Lista], RecorridoHermanos) :- preorder(Hijo, Recorrido),
        iterar_preorder(Lista, RecorridoHermano),
    	append(Recorrido, RecorridoHermano, RecorridoHermanos).</code></pre>
Árbol de ejemplo.<br><br>      
<pre><code>mi_arbol_n_ario( [5, [8, [7, [9]], [10]], [11, [1]]]).</code></pre>
</p>
<p align="center"><img src="images/arbol-n-ario-ej.png"></p>
<pre><code>?- mi_arbol_n_ario(Arbol), es_arbol_n_ario(Arbol), preorder(Arbol, Recorrido).
Arbol = [5, [8, [7, [9]], [10]], [11, [1]]],
Recorrido = [5, 8, 7, 9, 1.5, [hola, mundo], 3.3333, 10, 11, 1]</code></pre>
<h1>

<a id="11-ejemplo-grafos" class="anchor" href="#11-ejemplo-grafos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11. Ejemplos de Prolog</h1>
<h2><a id="11-ejemplo-grafos" class="anchor" href="#11-ejemplo-grafos" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.1 Ejemplos de Grafos </h2>
<h3><a id="11-ejemplo-grafos1" class="anchor" href="#11-ejemplo-grafos1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.1.1 Representación mediante aristas </h3>
<p>1. Implementar el siguiente grafo en Prolog y definir una regla para encontrar los caminos de un nodo.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/grafo.png?raw=true"></p>

<p>Todas las uniones entre dos nodos pueden ser representadas como hechos de relaciones, por tanto quedaría definido como:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/grafo1.png?raw=true"></p>

<p>2. Para determinar todos los caminos entre un nodo A y un nodo B en un grafo dirigido como el presentado a continuación, usando la representacion mediante sus aristas, es decir, sea G:</p>
<center> <img src="images/grafo.png"> </center>
<p>Y su representación dada por: </p>
<center> <img src="images/aristasG.png"> </center>
<p>Se sabe que un nodo A esta conectado con B si existe <b>arista(A,B) o arista(B,A)</b>.
Los caminos están representados por la lista de nodos a través de los cuales se debe viajar para pasar del nodo A al nodo B, sin repetir nodos. <br>
Luego, para encontrar los caminos de, por ejemplo, <b> e a d </b> se realiza: </p>
<center> <img src="images/ejCamGrafos.png"> </center>
<p>Obteniendo los caminos de e a d: </p>
<center> <img src="images/resCaminos.png"> </center>


<h3><a id="11-ejemplo-grafos2" class="anchor" href="#11-ejemplo-grafos2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.1.2 Otras representaciones de grafos </h3>
<p>Además de la representación a partir de aristas, se puede representar los grafos en Prolog de formas diferentes como:</p>
<ol> 
   <li><b>Forma grafo-término:</b> Cada grafo es un objeto con dos tipos de conjuntos, nodos y aristas </li> 
   <li><b>Forma lista de adyacencia:</b> Consiste de una lista de nodos donde se asocia cada nodo a los adyacentes a este.</li> 
   <li><b>Forma aristas y nodos:</b> Lista que consiste de elementos de la forma X-Y donde X y Y son nodos y - representa una arista entre estos. Los nodos que no tienen aristas se representan como elementos solos. </li> 
</ol>
<p>Dependiendo del tipo de grafo (dirigido o no dirigido) la representación varía:</p>
<ol> 
  <li> Grafos no dirigidos:</li>
  <p align="center"><br>
    <img src="https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/graph1.gif">
  </p>
  <p>Para el grafo no dirigido presentado, su representación sería:</p>
  <p align="center">
    <img src="images/grafosNoDir.png">
  </p>
  <li> Grafos dirigidos:</li>
  <p align="center"><br>
    <img src="https://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/graph2.gif">
  </p></ol>
  <p>Para el grafo dirigido presentado, su representación sería:</p>
  <p align="center">
    <img src="images/digrafos.png">
  </p>

<h2>
<a id="12-ejemplo-autómatas" class="anchor" href="#12-ejemplo-aut%C3%B3matas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.2 Ejemplo Autómatas</h2>

<p align="center">
<img src="images/automatas1.png">
</p>


<p>Implementar un AFD en prolog que acepte el lenguaje determinado por el siguiente autómata:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/automata.png?raw=true"></p>

<p align="justify">Un autómata puede verse como un grafo dirigido con un estado de inicio y otro de finalización. Podemos representar la unión entre estados como un hecho de relación y es importante hacer la definición del estado inicial y el estado final. El autómata quedaría definido como:</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/automata1.png?raw=true"></p>


<p>Vamos a verificar la anterior definición con una cadena que sí sea aceptada por el autómata. En este caso probaremos para la cadena <strong>[b,b,a,a,b,a,b]</strong>, verificando que es una cadena aceptada.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/automata2.png?raw=true"></p>

<p>Finalmente realizaremos la prueba con la cadena <strong>[b,b,a]</strong>, la cual debería ser rechazada.</p>

<p align="center">
<img src="https://github.com/mppinedav/prologtutorial/blob/master/automata3.png?raw=true"></p>

<h2>
<a id="13-ejemplo-sistema-experto" class="anchor" href="#13-ejemplo-sistema-experto" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.3 Ejemplo Sistema Experto</h2>


<p align="justify">Implementar un Sistema Experto en prolog que acepte el ayude al diagnostico de un conjunto de enfermedades:</p>

<p align="justify">Un sistema experto se define como un sistema que proveen una solución a los problemas en rangos específicos de conocimiento tan cercanas como un humano experto lo pudiese hacer, en prolog se pueden implementar con ayuda de los hechos conocidos por un experto humano. 
</p>

<p>Vamos a ver cada parte del sistema y que funcion cumple:</p>

<p align="center">
<img src="images/Sistema Experto 1.png">
</p>

<p align="justify">La primera parte, la regla evaluar es la cual inicia el proceso, esta asu vez llama a hipotesis, para luego de evaluarla escribir en consola la solucion que considera correcta segun los datos que tiene disponibles</p>

<p align="center">
<img src="images/Sistema Experto 2.png">
</p>

<p>En la regla "hipotesis" se enumeran las enfermedades las cuales puede diagnosticar el sistema experto</p>
<p align="center">
<img src="images/Sistema Experto 3.png">
</p>
<p>Cada enfermedad tiene una regla la cual liga los sintomas con la respectiva enfermedad, ademas de mostar los respectivos medicamentos recomenaddos</p>
<p align="center">
<img src="images/Sistema Experto 4.png">
</p>
<p align="justify">Cada regla de enfermedad usa "verificar" para reconocer si se sabe si el usuario tiene o no un sintoma en especifico, el hecho "si(sintoma)" no se encuentra en la base de conocimiento del sistema entonces se hace el llamado a la regla "preguntar(sintoma)"</p>
<p align="center">
<img src="images/Sistema Experto 5.png">
</p>

<p align="justify">La regla auxiliar "preguntar" sirve para recibir los datos del usuario, esta hace uso de la regla assert que trae prolog por defecto para poder añadir nuevos hechos a la base de conocimiento del sistema</p>

<p>Un ejemplo de la salida del sistema experto:</p>

<p align="center">
<img src="images/Sistema Experto 6.png">
</p>
<a href="https://swish.swi-prolog.org/p/fgRDDSpC.swinb">Ejemplo del sistema en Notebook de swish</a>

<h2><a id="14-ejemplo-quick-sort" class="anchor" href="#14-ejemplo-quick-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.4 Ejemplo de QuickSort</h1>

<p align="justify">Quick sort es uno de los algoritmos de ordenamiento más usados, veremos como sería una de las implementaciones en Prolog.</p>

<p align="justify">
  Sabemos que en QuickSort se utiliza un elemento pivote el cual partirá la lista en dos (los menores del pivote y los mayores a él). Recordar que quicksort usa la estrategia de dividir y vencer.
  Por lo cual, QuickSort lo podemos ver como dividir dos listas, ordenar cada una de esas listas con QuickSort y posterior a ello, juntar cada lista ordenada.
</p>
<p align="center">
  <img src="images/QuickSort 1.png">
</p>
<p align="justify">
  Ahora debemos definir <b>separar</b> que es la parte más interesante del programa. <b>separar</b> (el predicado) recibirá un pivote, una lista, unos menores y unos mayores.
  En caso se que el elemento A sea menor que el pivote le haremos append a la lista de mayores [A|May], en caso contrario lo enviaremos como tercer parámetro para la lista de menores.
</p>

<p align="center">
  <img src="images/QuickSort 2.png">
</p>

<p>
  Nota: El caso base de <b>separar</b> es cuando las dos listas están vacías y no importa el pivote que nos llegue.
</p>

<a href="https://swish.swi-prolog.org/p/PL2019-I.swinb">QuickSort más otros ejemplos lo podemos encontrar en este Notebook</a>

<h2><a id="15-ejemplo-compresor" class="anchor" href="#15-ejemplo-compresor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.5 Ejemplo de un compresor</h2>
<p>La compresión de datos se basa fundamentalmente en buscar repeticiones en series de datos para después almacenar solo el dato junto al número de veces que se repite. Así, por ejemplo, si en un fichero aparece una secuencia como "AAAAAA", ocupando 6 bytes se podría almacenar simplemente "6A" que ocupa solo 2 bytes. </p>
<p><span>Supongamos que se desea comprimir la siguiente cadena de n&uacute;meros y se desea comprimir la secuencia de n&uacute;meros contiguos, se puede hacer una compresi&oacute;n RLE</span><span></span><span>&nbsp;</span></p>
<p align="center">
  <img src="images/comprime1.png">
</p>
<p><span>Para este caso toda la secuencia ingresada ser&aacute; agrupada por el n&uacute;mero de repeticiones contiguas de s&iacute; misma.</span><span>&nbsp;</span></p>
<p><span>Aplicando inducci&oacute;n matem&aacute;tica se llega a los siguientes casos</span></p>
<ul>
<li><span>Lista vac&iacute;a.</span></li>
<li><span>Un &uacute;nico elemento: Cuando tenga solo un elemento no contiguo con otro no se har&aacute; compresi&oacute;n, evitando as&iacute; tener casos de este tipo (1,1).</span></li>
<li><span>Cuando ambos elementos contiguos son iguales: cuando se cumple el caso se aplica recursi&oacute;n con uno menos del resto y se acumula.</span></li>
<li><span>Cuando ambos elementos contiguos no son iguales: cuando se cumple el caso se retira el primero de la lista y se a&ntilde;ade al resto. </span></li>
</ul>


<p align="center">
  <img src="images/comprime2.png">
</p>
<p>Al dar como input por ejemplo: comprime([1,1,1,2,2,2,3,4,4], R). </p>
<p align="center">
  <img src="images/comprime3.png">
</p>
<p>La codificación <b>run-length</b> realiza una compresión de datos sin pérdidas y es muy utilizado en imágenes de 8 bits indexadas (en un principio fue utilizado para imágenes en blanco y negro). No funciona tan bien en imágenes donde varía constantemente el color de los píxels como fotografías, aunque JPEG lo utiliza de forma efectiva en los coeficientes que quedan después de transformar y cuantificar bloques de imágenes. </p>
<a href="https://swish.swi-prolog.org/p/Filia.swinb">Ejemplo compresión RLE -Notebook</a>

<h2><a id="17-ejemplo-dcg" class="anchor" href="#17-ejemplo-dcg" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.6 Ejemplo de DCG</h2>

<p>Uno de las aplicaciones por las cuales fue originalmente concebido Prolog por su autor Alain Colmerauer
  fue el de procesamiento de lenguaje natural. Esto se logra en Prolog gracias al uso de 
Definitive Clauses Grammar o por sus siglas en inglés DCG</p>
<p>Pero antes de entender mediante un ejemplo básico cómo funciona el DCG en Prolog es necesario hacer una breve
  introducción a las gramaticas libres de contexto.
</p>
<p>
  Donde la gramática libre de contexto es en esencia un conjunto de reglas que nos dicen si una "oración" está
  correctamente formulada (Es decir desde un punto de vista sintáctico). Un ejemplo de dicha gramática es $L=\left\lbracea^ib^jc^k | i+j=3k\right\rbrace$ como la que 
  se muestra a continuación
</p>
<p align="center">
  <img src="images/Grammar.png">
</p>
<p>La anterior gramática se refiere a palabras formadas por a,b,c de tal forma que se cumpla que $ L=\left\lbrace a^ib^jc^k | i+j=3k \right\rbrace $ .
  En esta gramática podemos identificar unas letras mayúsculas las cuales son los símbolos no terminales es decir que tienen producciones
  mientras que las letras minúsculas serán considerados como símbolos terminales de la gramática
</p>
<p>Lo anterior mencionado puede ser generalizado a casos más grandes incluso en el área de procesamiento de lenguaje natural es decir hacer que un
  computador logre entender idiomas como lo son el español, inglés, alemán, entre otros...
</p>
<p>
  Prolog facilita la labor de trabajar con gramáticas libre de contexto mediante el uso de los ya mencionados DCG, aunque
  tambien se puede realizar con la función append de listas.Nada mejor algo grafico para mostrar las facilidades que esta 
  posee para representar la gramática por medio de DCG:
</p>
<p align="center">
  <img src="images/grammar_english.png">
</p>
<p>Como podemos observar las similitudes entre la forma que estamos acostumbrados y la forma como le hacemos entender 
  mediante el uso de DCG la gramática con la queremos trabajar. Y la forma como se realizan consultas sobre si una estructura
  gramatical de una frase es correcta se realiza de la siguiente forma:
</p>
<p align="center">
  <img src="images/sintax.png">
</p>
<p>Ahora vamos a probar con la frase  woman a man love a y nos daremos que el resultado es el esperado, es decir falso</p>
<p align="center">
  <img src="images/incorrect.png">
</p>
<p>
  Sin embargo, podemos ahondar más en esta gramática que hace referencia al lenguaje inglés para añadir nuevas características. 
  Comencemos por una simplificación básica que nos permitirá construir sobre ella más adelante:
</p>

<p align="center">
  <img src="images/english_grammar_1.png">
</p>

<p>
  Esta gramática hace referencia al caso extremadamente estricto de oraciones simples en inglés de la forma: sustantivo, luego verbo, con la opcionalidad de tener de nuevo un sustantivo o no. Podemos mejorarla al añadir una frase sustantiva, que permita añadir un determinador opcional a la oración.
</p>

<p align="center">
  <img src="images/english_grammar_2.png">
</p>

<p>
  Aquí podemos notar varias cosas. <code>sentence, noun_phrase y verb</code> son conocidos como los términos sintácticos. Esto indica que hacen parte de la estructura del lenguaje inglés. Por otra parte la lista de paréntesis cuadrados son usados para indicar que son parte del vocabulario del lenguaje, y no hacen parte de la estructura del lenguaje; también conocidos como terminales.
</p>

<p>
  Elaborando un poco más, podemos añadir verbos compuestos al añadir la regla <code>verb-->[will_see].</code>; además que podemos añadir el uso de adjetivos que nos permitirán crear oraciones más complejas.
</p>

<p align="center">
  <img src="images/english_grammar_3.png">
</p>

<p>
  Esta última gramática no tiene en cuenta la pluralidad de los sustantivos en conjunción con sus verbos. Así que podemos implementar reglas particulares para sustantivos y verbos de tal manera que se asignen a sustantivos (plurales y singulares) sus verbos en forma correcta. Los primeros 4 verbos son etiquetados como <code>ambos</code> para indicar que tienen la misma forma tanto en plural como singular.
  Y una vez hayamos añadido estos cambios, deberemos soportar esta pluralidad en la creación de oraciones y frases sustantivas.
</p>

<p align="center">
  <img src="images/english_grammar_4.png">
</p>

<p>
  Ahora podemos hacer unas cuantas consultas para darle uso a este analizador de lenguaje natural.
</p>

<p align="center">
  <img src="images/english_grammar_5.png">
</p>

<p>
  Esto nos permite un sinfín de cosas más como crear el árbol sintáctico correspondiente, entre otras que se dejan
  como tarea de revisión al lector.  
</p>
<h2><a id="16-hanoi" class="anchor" href="#16-hanoi" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.7 Problema de Torres de Hanoi</h2>

<p align="center">
  <img src="images/torres-de-hanoi.png">
</p>
<p>
  El problema consiste en:
  <ul>
    <li>Hay un stack de N discos están organizados del más grande al más pequeño, de abajo hacia arriba en una barilla.</li>
    <li>Hay otras dos varillas que no tienen discos, una es nuestro objetivo donde queremos pasar los discos de forma ordenada y la otra nos va a servir de auxiliar.</li>
    <li>Queremos el mínimo número de movimientos para mover el stack de la varilla inicial a la varilla objetivo.</li>
  </ul>
</p>
<p>En cuestión, se puede solucionar de manera recursiva, donde podemos definir tres casos.</p>
<p>El caso base, que es cuando en la varilla A hay un sólo elemento, por lo cual el disco se mueve directamente a C. Lo definimos de la siguiente manera en Prolog</p>
<p align="center">
    <img src="images/hanoi_base_case.png">
  </p>
<p align="justify">Y el caso recusivo, es cuando N>1 en el cual podemos definir que primero pase N-1 discos de A a B, usando C, luego el disco que queda lo pasamos de A a C, y en última instancia 
  se pasarían los discos que hay en B a C. Lo definimos en Prolog de la siguiente manera.
</p>
<p align="center">
  <img src="images/hanoi_recursivo.png">
</p>
<p>A continuación podemos ver la resolución del objetivo con tres discos.</p>
<p align="center">
  <img src="images/hanoi_solv.png">
</p>

<p>
  <a target="_blank" href="https://swish.swi-prolog.org/p/LP-2019-2-fork.swinb">Aquí</a> 
  encontrarás un tutorial completo de Prolog, que va desde sus estructuras más simples, hasta ejemplos avanzados como un sistema experto.
</p>

<h2><a id="18-ejemplo-bubble" class="anchor" href="#18-ejemplo-bubble" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.8 Ejemplo de Bubble Sort</h2>
<p>En Prolog, para el algoritmo de Bubble Sort es necesario comparar los dos elementos de la lista restante en cada evaluación recursiva y hacer el intercambio de estos en una lista auxiliar, hasta obtener la lista ordenada. 
  La implementación en Prolog se presenta a continuación:
</p>
<p align="center">
  <img src="images/bubbleSort.png">
</p>

<h2><a id="19-ejemplo-analizador" class="anchor" href="#19-ejemplo-analizador" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.9 Ejemplo Doomie de Analizador Sintáctico del Inglés</h2>
<p>
  El modelo del lenguaje inglés consta de siete categorías o tipos de lexema : </p>
<ul>
  <li>Sustantivo</li>
  <li>Verbo</li>
  <li>Adjetivo</li>
  <li>Adverbio</li>
  <li>Artículo</li>
  <li>Conjunción</li>
  <li>Preposición</li>
</ul>
<p>
  La gramática es sensible al contexto en tanto que obliga que haya coherencia cuantitativa entre sustantivos y verbos, así como entre sustantivos y artículos 
  — e.g., a man likes a dog (es coherente) ; a man likes a dogs (no es coherente).
</p>
<h3>Axiomas</h3>
<p>
  Las reglas sintácticas del inglés están pensadas en términos de los tipos de lexema propios del lenguaje, que en la práctica deben ser reemplazados por lexemas particulares. 
  Por esa razón se construye la estructura axiomática del sistema formal que modela la gramática del inglés con un arbol que progresa desde las categorías más generales hasta los lexemas particulares — en términos formales, 
  se progresa desde los símbolos de la gramática hasta los valores terminales.
</p>
<p>
  En la siguiente celda de código, el conjunto de instancias del predicado <strong>isa(X, Y)</strong> implementa esta estructura arbórea :
</p>
<ul>
  <li><strong>Primer Nivel:</strong>
    <ul>
      <li>word → noun | verb | article</li>
    </ul>
  </li>
  <li><strong>Segundo Nivel:</strong>
    <ul>
      <li>noun → singular_noun | plural_noun</li>
      <li>verb → singular_verb | plural_verb</li>
      <li>article → singular_article | plural_article | neutral_article</li>
    </ul>
  </li>
  <li><strong>Tercer Nivel:</strong>
    <ul>
      <li>singular_noun → man | dog | woman | leg</li>
      <li>plural_noun → men | dogs | women | legs</li>
      <li>singular_verb → bites | likes</li>
      <li>plural_verb → bite | like</li>
      <li>singular_article → a</li>
      <li>neutral_article → the</li>
    </ul>
  </li>
</ul>
<p align="center">
  <img src="images/analizador1.PNG">
</p>
<p>
  La siguiente celda termina de definir el carácter de los lexemas del lenguaje:
</p>
<p align="center">
  <img src="images/analizador2.PNG">
</p>
<p>
  ¿Por qué no se les implementó, deberá preguntarse el lector, de manera afín a como se implementó a sus predecesores, los sustantivos, verbos y artículos? 
  Porque, como se verá en breve, mientras que conviene a la implementación del analizador sintáctico abstraer tipos de lexema en ciertos casos, 
  en otros casos es del todo innecesario.
</p>
<p>
  Para el caso de los terminales de la penúltima celda es esencial no solamente poder atribuirles su carácter como sustantivo, verbo o artículo, sino también como singular o plural.
  En esta implementación se optó, con fines educativos, por implementar dichas atribuciones por medio de la herencia : se entiende que si un nodo padre, 
  en la estructur arbórea antes descrita, posee ciertas propiedades, los nodos que se desprendan de él también las tendrán. Esto es algo del todo innecesario en la consideración de otras clases de lexema, 
  los adjetivos, adverbios, etc. de ahí que no se les implemente con el predicado <strong>isa(X, Y)</strong>, y sí con predicados más simples : al no ser de interés atribuirles más propiedad que la que su mismo predicado les atribuye, 
  tampoco es de interés implementar para ellos ninguna forma de herencia.
</p>
<p>
  Las atribuciones hechas a los terminales de la penúltima celda están implementadas en esta:
</p>
<p align="center">
  <img src="images/analizador3.PNG">
</p>
<p>
  Y la herencia de dichas atribuciones está implementada en esta:
</p>
<p align="center">
  <img src="images/analizador4.PNG">
</p>
<h3>Reglas de Inferencia</h3>
<p>
  La anterior celda de código ya definía ambas cláusulas de la regla <strong>hasproperty(Object, Property, Value)</strong>. 
  En lo que sigue se presentará otras reglas de inferencia, a partir de las que se construirá incrementalmente el analizador sintáctico.
</p>
<p>
  La primera regla, para la verificación de frases nominales, 
  es <strong>nounphrase(...)</strong>, y cuenta con varias cláusulas :
</p>
<ul>
  <li><strong>La primera cláusula</strong> estipula que un sustantivo es una frase nominal.</li>
  <li><strong>La segunda cláusula</strong> estipula que un artículo seguido por un sustantivo es una frase nominal.</li>
  <li><strong>La tercera cláusula</strong> estipula que un sustantivo seguido por un adjetivo es una frase nominal.</li>
  <li><strong>La cuarta cláusula</strong> estipula que un artículo, seguido por un adjetivo, seguido por un sustantivo, es una frase nominal.</li>
  <li><strong>La quinta cláusula</strong> estipula que un adverbio adjetival, seguido por un adjetivo, seguido por un sustantivo, es una frase nominal.</li>
  <li><strong>La sexta cláusula</strong> estipula que un artículo, seguido por un adverbio adjetival, seguido por un adjetivo, seguido por un sustantivo, es una frase nominal.</li>
  <li><strong>La séptima cláusula</strong> estipula que una preposición seguida por una frase nominal es una frase nominal.</li>
</ul>
<p>
  Nótese que las cláusulas 2, 4 y 6, al contener sustantivos y artículos, obligan que ambos sean singulares o plurales (puesto que ambos deben tener el mismo valor de <strong>Number</strong>) :
</p>
<p align="center">
  <img src="images/analizador5.PNG">
</p>
<p align="center">
  <img src="images/analizador6.PNG">
</p>
<p>
  La segunda regla, para la verificación de frases verbales, es <strong>verbphrase(...)</strong>, y cuenta con varias cláusulas:
</p>
<ul>
  <li><strong>La primera cláusula</strong> estipula que un verbo es una frase verbal.</li>
  <li><strong>La segunda cláusula</strong>  estipula que un verbo seguido por una frase nominal es una frase verbal.</li>
  <li><strong>La tercera cláusula</strong> estipula que un adverbio seguido por un verbo, seguido por una frase nominal, es una frase verbal.</li>
  <li><strong>La cuarta cláusula</strong> estipula que un adverbio seguido por otro adverbio, seguido por un verbo, seguido por una frase nominal, es una frase verbal.</li>
</ul>
<p>
  Nótese que, por un lado, si el verbo y la frase nominal que le sigue tienen ambos el mismo número gramatical es irrelevante, 
  por lo que el valor de <strong>Number</strong> en <strong>nounphrase(..., Number)</strong> es <strong>_</strong>, y que, por otro lado, el axioma anteriormente declarado <strong>ad_adverb(quite)</strong>. 
  significa que la palabra inglesa 'quite' es un adverbio que puede modificar a otro adverbio.
</p>
<p>
  El código que implementa esta segunda regla:
</p>
<p align="center">
  <img src="images/analizador7.PNG">
</p>
<p>
  La tercera regla, para la verificación de frases preposicionales, es <strong>prepphrase(...)</strong>, y estipula que una preposición seguida por una frase nominal es una frase preposicional:
</p>
<p align="center">
  <img src="images/analizador8.PNG">
</p>
<p>
  La cuarta regla, para la detección de conectores, es <strong>connector(...)</strong>, y retorna si el primer lexema de una secuencia de lexemas dada es un conector o no:
</p>
<p align="center">
  <img src="images/analizador9.PNG">
</p>
<p>
  La quinta regla, para la verificación de oraciones, es <strong>sentence(...)</strong>, y tiene varias cláusulas:
</p>
<ul>
  <li><strong>La primera</strong> estipula que una frase nominal seguida por una frase verbal es una oración.</li>
  <li><strong>La segunda</strong> estipula que una frase nominal seguida por una frase verbal, seguida por una frase preposicional, es una oración.</li>
</ul>
<p>
  Nótese que el número gramatical de la frase nominal debe ser el mismo de la frase verbal que la sigue:
</p>
<p align="center">
  <img src="images/analizador10.PNG">
</p>
<p>
  La sexta y última regla, para la verificación de articulaciones (las estructuras sintácticas más generales, 
  análogas a lo que sería el programa si se tratara d eun lenguaje de programación), es <strong>utterance(...)</strong>, y tiene varias cláusulas:
</p>
<ul>
  <li><strong>La primera</strong> estipula que una oración es una articulación.</li>
  <li><strong>La segunda</strong> estipula que una oración seguida por un conector, seguido por una frase preposicional, es una articulación.</li>
  <li><strong>La tercera</strong> estipula que una oración seguida por un conector, seguido por una articulación, es una articulación.</li>
</ul>
<p>
  El código que implementa la regla:
</p>
<p align="center">
  <img src="images/analizador11.PNG">
</p>
<p>
  Una anotación final es pertinente: la variable <strong>Rest</strong> actúa como una variable de retorno, y adquiere su valor cuando, 
  en la cabecera de distintas reglas de inferencia, se designa la cola de una lista como <strong>Rest</strong> (véase las reglas <strong>nounphrase(...)</strong>, por ejemplo). 
  En ocasiones la variable <strong>End</strong> actúa de forma similar, solo que mientras que <strong>Rest</strong> denota lo que falta por procesar de la lista de lexemas, 
  <strong>End</strong> denota lo último que se va a procesar. <strong>LastBit</strong> en la regla de inferencia <strong>sentence(...)</strong> representa lo que sería un punto intermedio entre <strong>Rest</strong> y <strong>End</strong>, y 
  <strong>Next_phrase</strong> en la regla de inferencia <strong>utterance(...)</strong> representa lo que sería <strong>Rest</strong> antes de <strong>Rest</strong> mismo.
</p>
<p>
  <a target="_blank" href="https://swish.swi-prolog.org/p/TUTORIAL%20PROLOG.swinb">Notebook del Ejemplo Doomie de Analizador Sintáctico del Inglés implementado.</a> 
</p>


<h2><a id="20-ejemplo-sistema-experto-animales" class="anchor" href="#20-ejemplo-sistema-experto-animales" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11.10 Ejemplo Sistema Experto Animales</h2>


<p align="justify">En este ejemplo se lleva a cabo la implementación de un Sistema Experto en prolog que permite identificar un animal dentro de un conjunto de animales definidos por características.</p>
<p align="justify">Un sistema experto es un sistema computacional que emula la capacidad de tomar decisiones de un humano experto. Está compuesto por una base de conocimiento y un motor de inferencia, el cual recibe las características de una entidad o un problema. Comparando el conocimiento previo existente en la base de conocimientos con las características de la entidad es posible identificarlo y, en consecuencia, producir un diagnóstico o deducción.
</p>

<p>Las siguientes son las partes del sistema:</p>

<p>Primero se define la regla, con la cual se inicia el proceso. Esta regla llama a las hipótesis, luego realiza el proceso para evaluarlas y, finalmente, escribe en consola la solución final.</p>
<p align="center">
<img src="images/Sistema Animales 1.png">
</p>

<p align="justify">Se define una lista con las hipótesis que van a ser puestas a prueba. Estas hipótesis son excluyentes entre ellas (por ejemplo, el animal no puede ser un tigre y una jirafa al mismo tiempo). </p>

<p align="center">
<img src="images/Sistema Animales 2.png">
</p>

<p>Luego, se identifican las características por las cuales se puede diferenciar cada animal.</p>
<p align="center">
<img src="images/Sistema Animales 3.png">
</p>
<p>Se puede ver que cada una de ellas llama a "verificar"; de esta manera, se le preguntará al usuario si el animal que busca tiene una característica en particular. Con esta información se alimenta la base de conocimiento.</p>
<p align="center">
<img src="images/Sistema Animales 4.png">
</p>
<p align="justify">La regla auxiliar "ask" sirve para recibir los datos del usuario: esta hace uso de la regla "assert" que trae prolog por defecto, la cual permite añadir nuevos hechos a la base de conocimiento del sistema.</p>
<p align="center">
<img src="images/Sistema Animales 5.png">
</p>



<h3>Ejemplos de la salida del sistema</h3>

<p>Resultado de búsqueda de <strong>jaguar</strong>:</p>
<p align="center">
<img src="images/Sistema Animales 6.png">
</p>


<p>Resultado de búsqueda de <strong>zebra<strong>:</p>
<p align="center">
  <img src="images/Sistema Animales 7.png">
  </p>
<a href="https://swish.swi-prolog.org/p/animalesSistema.pl">Ejemplo para ejecutar en entorno de swish</a>



<h1><a id="15-Aplicaciones" class="anchor" href="#15-Aplicaciones" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>12. Aplicaciones</h1>
<p align="center">
<img src="images/Aplicaciones.png">
</p> 

<p align="justify">Una de las aplicaciones más importantes por las que Prolog fue reconocido en el mundo, fue por su participación en la quinta generación de computadores.</p>
<p align="justify">Este proyecto tiene como objetivo principal implementar la inteligencia artificial (IA) mediante software o hardware escrito en Prolog, para ejecutar la traducción automática de un lenguaje a otro, es decir: de español a inglés o de inglés a japonés entre otros.</p>
<p align="justify">Aunque el proyecto no tuvo un resultado satisfactorio, fue un gran avance para lo que hoy en día conocemos como las traducciones automáticas, principalmente en páginas web.</p>
<p align="center">
  <img src="images/traduccion.png">
</p> 

<h1>
<a id="16-Des-Ven" class="anchor" href="#16-Des-Ven" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>13. Desventajas / Ventajas</h1>

<p align="center">
<img src="images/des-ven.png">
</p>

<hr>
<p> Tutorial sobre conceptos básicos.<a href="https://www.dropbox.com/s/gxev7r4rhxrd66e/Prolog.pdf?dl=1"> Enlace de descarga.</a> </p>
<p align="center">
  <embed src="Prolog.pdf" width="700" height="385"type='application/pdf'>
</p>
<p> Tutorial + IDE Online .<a href="http://swish.swi-prolog.org/"> Ide Online.</a> </p>
<p align="center">
  <embed src="TutorialProlog2017I.pdf" width="700" height="385"type='application/pdf'>
</p>
    <br>
    <a href="https://swish.swi-prolog.org/p/Tutorial%20de%20prolog.swinb">Tutorial de Prolog en Notebook de SWISH
    <br><br>
    <img src="images/TutorialProlog.PNG"></a>
<hr/>
<a href="https://swish.swi-prolog.org/p/ExpoPrologLP.swinb"> Tutorial de Prolog 2021-I, desarrollado en 
  SWISH.</a>
<p align="center">
  <embed src="TutorialProlog2021.pdf" width="700" height="385"type='application/pdf'>
</p>

<a href="https://swish.swi-prolog.org/p/TUTORIAL%20PROLOG.swinb"> Tutorial de Prolog 2021-II, desarrollado en 
  SWISH.</a>
<p align="center">
  <embed src="TUTORIAL_PROLOG_2021-II.pdf" width="700" height="385"type='application/pdf'>
</p>

<p align="center">
  <embed src="TUTORIALPROLOG2022II.pdf" width="700" height="385"type='application/pdf'>
</p>

<h2>
<a id="esperamos-que-el-tutorial-haya-sido-de-su-agrado-todos-los-ejercicios-trabajados-pueden-encontrarlos-en-este-notebook" class="anchor" href="#esperamos-que-el-tutorial-haya-sido-de-su-agrado-los-ejercicios-trabajados-pueden-encontrarlos-en-este-notebook" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Esperamos que el tutorial haya sido de su agrado. Los ejercicios trabajados pueden encontrarlos en este <a href="http://swish.swi-prolog.org/p/tutorialprolog.swinb">notebook</a>
</h2>

<p>Este tutorial fue desarrollado por Mónica Pineda, Jorge Bonilla y Diego Poveda.</p>
<p>Colaboradores : Jaime Andres Vargas y Jonathan Alberto Ortiz</p>
<p>                Santiago Carvajal Castañeda y Mario Andrés Moreno</p>
<p>                Julián Esteban Salomón y Cristian David González</p>
<p>                Cristian Laiton y David Hormaza.</p>
<p>                Luis Castro y Wilson Piravaguen.</p>
<p>                Andrés Fernando Román Arévalo.</p>
<p>                Alci René Ramírez Soto.</p>
<p>                Jonathan López Castellanos, Victor Barragán Páez y Wilson Arévalo Rodríguez.</p>
<p>                María Fernanda Carbonell Santos, Juan David González Muñoz, Ivan Alejandro Cruz Tole y Yuli Beltran Rozo</p>
<p>                Julián Andrés Pereira, Jefferson Daniel Castro, Nicolás Andrés Caicedo, Gabriel Enrique Ramirez </p>
<p>                Andrea Katerine Calderón, Angela Maria Cardenas, Valentina Colmenares, Luis Alfonso Díaz</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mppinedav/prolog">Prolog</a> is maintained by <a href="https://github.com/ferestrepoca/paradigmas-de-programacion/tree/gh-pages/proglogica/tutoriales/prolog-gh-pages">link</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.singlePageNav.min.js"></script>

  </body>
</html>
