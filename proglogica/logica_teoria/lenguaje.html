<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Programación lógica UNAL</title>
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <meta content="" name="keywords">
  <meta content="" name="description">

  <!-- Favicons -->
  <link href="img/favicon.ico" rel="icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,700,700i|Poppins:300,400,500,700"
    rel="stylesheet">

  <!-- Bootstrap CSS File -->
  <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Libraries CSS Files -->
  <link href="lib/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link href="lib/animate/animate.min.css" rel="stylesheet">

  <!-- Main Stylesheet File -->
  <link href="css/style.css" rel="stylesheet">
</head>

<body>

  <!--==========================
    Header
    ============================-->
  <header id="header">
    <div class="container">

      <div id="logo" class="pull-left">
        <a><img src="img/logo.png" class="resize" /></img></a>
      </div>

      <nav id="nav-menu-container">
        <ul class="nav-menu">
          <li class="menu-has-children"><a href="index.html#hero">Paradigma</a>
            <ul>
              <li><a href="index.html#about">Definición</a></li>
              <li><a href="index.html#comparacion">Imperativo vs Declarativo</a></li>
            </ul>
          </li>
          <li class="menu-has-children"><a href="proglogica.html">Programación lógica</a>
            <ul>
              <li><a href="proglogica.html#filosofia">Filosofía del paradigma</a></li>
              <li><a href="proglogica.html#definicion">¿Qué es?</a></li>
              <li><a href="proglogica.html#historia">Historia</a></li>
              <li><a href="proglogica.html#logica">Lógica</a>
                <ul>
                  <li><a href="proglogica.html#logica_definicion">Definición</a>
                  <li><a href="proglogica.html#logica_cero">Lógica de orden cero</a>
                  <li><a href="proglogica.html#logica_uno">Lógica de primer orden</a>
                  <li><a href="proglogica.html#logica_dos">Lógica de segundo orden</a>
                </ul>
              </li>
              <li><a href="proglogica.html#conceptos">Conceptos claves</a>
                <ul>
                  <li><a href="proglogica.html#hechos">Hechos</a>
                  <li><a href="proglogica.html#l#reglas">Reglas</a>
                  <li><a href="proglogica.html#consultas">Consultas</a>
                  <li><a href="proglogica.html#recursion">Recursión</a>
                  <li><a href="proglogica.html#ejemplo">Ejemplo</a>
                </ul>
              </li>
              <li><a href="proglogica.html#ventajas">Ventajas y desventajas</a></li>
            </ul>
          </li>
          <li class="menu-active menu-has-children"><a href="lenguaje.html">Lenguajes lógicos</a>
            <ul>
              <li><a href="lenguaje.html#prolog">Prolog</a></li>
              <li><a href="lenguaje.html#mercury">Mercury</a></li>
              <li><a href="lenguaje.html#clp">CLP (FD)</a></li>
              <li><a href="lenguaje.html#cycl">CycL</a></li>
              <li><a href="lenguaje.html#godel">Godel</a></li>
              <li><a href="lenguaje.html#minikanren">miniKanren</a></li>
              <li><a href="lenguaje.html#sequencel">SequenceL</a></li>
              <li><a href="lenguaje.html#datalog">Datalog</a></li>
              <li><a href="lenguaje.html#ejemplos">Ejemplos</a></li>
              <li><a href="lenguaje.html#ejemplo_comparativo">Ejemplo comparativo</a></li>
            </ul>
          </li>
          <li class="menu-has-children"><a href="aplicaciones.html">Aplicaciones</a>
            <ul>
              <li><a href="aplicaciones.html#ai">Inteligencia artificial</a></li>
              <li><a href="aplicaciones.html#sist_experto">Sistemas Expertos</a></li>
              <li><a href="aplicaciones.html#demostracion">Demostración automática de problemas</a></li>
              <li><a href="aplicaciones.html#reconocimiento">Reconocimiento de lenguaje natural</a></li>
              <li><a href="aplicaciones.html#procesamiento">Procesamiento de lenguaje natural</a></li>
              <li><a href="aplicaciones.html#sist_admon">Sistemas de gestión de bases de datos relacionales</a>
              </li>
              <li><a href="aplicaciones.html#resolucion">Resolución de ecuaciones simbólicas</a></li>
              <li><a href="aplicaciones.html#consultas">Consultas lógicas basadas en reglas</a></li>
              <li><a href="aplicaciones.html#Logica_probabilistica">Programación lógica probabilística</a></li>
            </ul>
          </li>
          <li><a href="presentaciones.html">Presentaciones y otros</a></li>
        </ul>
      </nav><!-- #nav-menu-container -->
    </div>
  </header><!-- #header -->

  <main id="main" style="padding-top: 72px;">

    <!--==========================
        Content Section
        ============================-->
    <section id="lista" style="margin-top:30px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Lenguajes</strong></h2>
          <p>Los siguientes son algunos de los lenguajes de programación que emplean como paradigma la <b>programación
              lógica</b>.</p>
          <ul>
            <li>Prolog</li>
            <li>Mercury</li>
            <li>CLP (FD)</li>
            <li>CSP (Constraint Satisfaction Problem)</li>
            <li>Lambda Prolog</li>
            <li>Logtalk</li>
            <li>Alma-0</li>
            <li>CLAC(Logical Composition with the Assistance of Computers)</li>
            <li>Gödel</li>
            <li>miniKanren</li>
            <li>Curry</li>
            <li>Ace</li>
            <li>PALs</li>
            <li>Actor Prolog</li>
            <li>SequenceL</li>
            <li>Datalog (Logic Programming in Python)</li>
            <li>Absys</li>
            <li>Vadalog</li>
            <li>CycL</li>
          </ul>
          <p><a href="http://swish.swi-prolog.org/p/Paradigma%20Programacion%20Logica.swinb">Ejemplos en SWI-Prolog
              listos para ejecutar.</a></p>
          <p>Ejemplo en Jupyter Notebook, utilizando kernel Calysto_prolog (<a href="docs/EjemplosProlog.ipynb">Descarga</a>)(<a href="https://colab.research.google.com/github/ferestrepoca/paradigmas-de-programacion/blob/gh-pages/proglogica/logica_teoria/docs/EjemplosProlog.ipynb">Colab</a>).</p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="prolog" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Prolog</strong></h2>
          <p>Es un Lenguaje de Programación diseñado para representar y utilizar el conocimiento que se tiene sobre
            un determinado dominio. Los programas en Prolog responden preguntas sobre el tema del cual tienes
            conocimiento.</p>
          <p>La popularidad del lenguaje se debe a su capacidad de deducción y además es un lenguaje fácil de usar
            por su semántica y sintaxis. Solo busca relaciones entre los objetos creados, las variables y las
            listas, que son su estructura básica.
          </p>
          <p>Escribir un programa en Prolog consiste en declarar el conocimiento disponible acerca de objetos, además
            de sus relaciones y sus reglas, en lugar de correr un programa para obtener una solución, se hace
            una pregunta, el programa revisa la base de datos para encontrar la solución a la pregunta, si existe
            mas de una solución, Prolog hace un barrido para encontrar soluciones distintas. El propio sistema
            es el que deduce las respuestas a las preguntas que se le plantean, dichas respuestas las deduce
            del conocimiento obtenido por el conjunto de reglas dadas.</p>
          <p style=" display: flex; justify-content: center;"><img src="img/prologhw.PNG" style="width: 90%; max-width: 600px;"></p>
          <ul>
            <li>Alain Colmerauer y Philippe Roussel (Finales de los 70’s).</li>
            <li>Proviene del francés PROgrammation en LOGique.</li>
            <li>Producción interpretada.</li>
            <li>Se basa en Lógica de primer orden.</li>
            <li>Es declarativo.</li>
            <li>Backtracking.</li>
            <li>Compilador de ProLog online: <a href="https://swish.swi-prolog.org/">https://swish.swi-prolog.org/</a>.
            </li>
          </ul>
          <br>
          <strong>Ejemplos de aplicación</strong>
          <ul><li><strong>Genexus y Linx:</strong> plataformas Low-code desarrolladas utilizando Prolog. <br>
            Low-code es una modalidad de desarrollo de software que permite que los programadores diseñen aplicaciones
            rápidamente y con un mínimo de codificación manual por medio de un sistema de arrastrar y soltar. 
            Funciona a través de una interfaz visual con lógica simple, en donde se abstrae el código de las 
            acciones y comandos, haciendo el proceso mucho más sencillo.
            </li></ul>
          
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="mercury" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Mercury</strong></h2>
          <p>
            Mercury es un lenguaje de alto nivel (es decir, no se preocupa de problemas como la reserva y liberación de
            memoria) derivado
            de Prolog, pero con una implementación que le hace ser más útil para representar y tratar problemas
            del mundo real. Combina toda la expresividad del lenguaje declarativo con avanzadas técnicas de análisis
            estático y detección de errores. Es un lenguaje compilado, lo que le permite detectar numerosos errores
            antes de poder ejecutar la aplicación. El compilador “traduce” el programa de lenguaje Mercury a
            C, que es un lenguaje portable a cualquier plataforma. Además, al igual que el lenguaje de Gödel,
            Mercury es un lenguaje que utiliza módulos, lo que da una gran modularidad en el desarrollo de aplicaciones,
            solventando así uno de los mayores problemas a los que se enfrentaban los lenguajes de programación
            lógicos.
          </p>
          <ul>
            <li>Es puramente declarativo Æ los predicados y funciones en Mercury siempre obtienen conclusiones lógicas.
            </li>
            <li>La comunicación con el programa es mediante una librería de funciones que necesitan como parámetro el
              estado anterior del “mundo” además del resto de parámetros que considere el usuario necesario y dan
              como salida el nuevo estado del “mundo” además de otros resultados específicos.</li>
            <li>
              La declaración de tipos en Mercury se hace de manera lógica:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/mer001.PNG" style="width: 70%; max-width: 400px;"></p>
            </li>
            <li>
              Se puede predeterminar el número de veces que se va a llamar a un predicado dentro del programa.<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/mer002.PNG" style="width: 90%; max-width: 540px;"></p> “det”
              indica
              una vez, “semidet” como mucho una vez, “multi” al menos una vez y “nondet” un número arbitrario de
              veces El compilador comprobará que se cumple y, en caso contrario, rechazará el programa.
            </li>
            <li>Mercury tiene un sistema modular. Los programas consisten en la composición de uno o más módulos. Cada
              módulo tiene una sección llamada <i>interface</i> donde se declaran todos los tipos, funciones y
              predicados que se pueden exportar a otros módulos y otra sección <i>mplementation</i> donde están
              las definiciones de las entidades exportadas así como definiciones de tipos y predicados no exportables,
              locales al módulo.</li>
            <li>El compilador genera código muy eficiente.</li>
          </ul>
          <p style=" display: flex; justify-content: center;"><img src="img/mer003.PNG" style="width: 70%; max-width: 400px;"></p>

          <ul>
            <li>Fergus Henderson, Thomas Conway y Zoltan Somogyi (1995).</li>
            <li>Sintaxis parecida a ProLog.</li>
            <li>Diseñado para resolver “aplicaciones del mundo real” de forma robusta.</li>
            <li>Soporta polimorfismo.</li>
            <li>Un programa escrito en Mercury es más rápido que uno equivalente realizado en Prolog.</li>
          </ul>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="clp" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>CLP (FD)</strong></h2>
          <p>
            Otra extensión de Prolog, especializado en los problemas <b>CSPs (Constraint Satisfaction Problem)</b>.
            De forma general, podemos decir que un programa en CLP(FD) consta de tres partes: “generación
            de variables” (donde también se especifica su domino), “definición de restricciones” (sobre las
            variables) y “labeling”, donde se instancian las variables por enumeración.
          </p>
          <b>Ejemplo:</b> SEND MORE MONEY puzzle:<br><br>
          <p style=" display: flex; justify-content: center;"><img src="img/clp.PNG" style="width: 90%; max-width: 600px;"></p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="cycl" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>CycL</strong></h2>
          <p>
            CycL es el lenguaje de programación lógica asociado con el sistema Cyc, que es una base de conocimiento 
            de inteligencia artificial y un proyecto de investigación con el objetivo de codificar conocimientos 
            generales en forma computable. El sistema Cyc utiliza CycL para representar la información y las reglas 
            que permiten a la máquina razonar acerca de ese conocimiento de una manera que imita el razonamiento humano.
          </p>
          <p>
            CycL es un lenguaje extremadamente expresivo y permite la representación de conocimientos muy detallados 
            y sutiles sobre el mundo. Permite declarar hechos, reglas, y realizar consultas complejas. También puede
             manejar excepciones y tiene la capacidad de representar el conocimiento contextual, lo que significa que 
             puede entender cuándo ciertas reglas o hechos se aplican y cuándo no, basándose en el contexto dado.
          </p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="godel" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Godel</strong></h2>
          <p>
            Gödel es un lenguaje en el que las sentencias lógicas llevan un orden y en el que existe el polimorfismo.
            Está basado en
            módulos (que aceptan polimorfismo) y en tipos de datos (soporta enteros y racionales con una
            precisión infinita, y número en coma flotante) y tiene una amplia librería de módulos predefinidos.
          </p>
          <p>
            Es un buen lenguaje para tareas de meta-programación, tales como compilación, depuración, análisis,
            verificación o transformación
            de programas, ya que es mucho más declarativo que Prolog, por ejemplo. Como curiosidad, se puede
            destacar que este lenguaje no funciona en un entorno Windows.
          </p>
          <b>Ejemplo:</b> Máximo Común Divisor:<br><br>
          <p style=" display: flex; justify-content: center;"><img src="img/godel.PNG" style="width: 90%; max-width: 600px;"></p>
        </div>
      </div>
    </section><!-- #content -->


    <!--==========================
        Content Section
        ============================-->
    <section id="minikanren" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>miniKanren</strong></h2>
          <p>miniKanren es un lenguaje específico de dominio incorporado para la programación lógica.</p>
          <p>El lenguaje central miniKanren es muy simple, con solo tres operadores lógicos y un operador de interfaz.
            miniKanren se ha implementado en un número creciente de lenguajes de host, incluidos Scheme, Racket,
            Clojure, Haskell, Python, JavaScript, Scala, Ruby, OCaml y PHP, entre muchos otros idiomas.</p>
          <p>miniKanren está diseñado para ser modificado y ampliado fácilmente; las extensiones incluyen la
            Programación Lógica de Restricciones, programación de lógica probabilística, programación lógica nominal y
            presentación.</p>
          <p>
            A continuaccion un ejemplo de la implementacion de esta libreria en python con un enfoque de pade hijo.
          </p>
          <p style=" display: flex; justify-content: center;"><img src="img/pykanren4.PNG" style="width: 80%; max-width: 480px;"></p>
          <p>Ahora tratemos de obtener un padre de Bart.</p>
          <p style=" display: flex; justify-content: center;"><img src="img/pykanren5.PNG" style="width: 80%; max-width: 480px;"></p>
          <p>Ahora los dos hijos de homero.</p>
          <p style=" display: flex; justify-content: center;"><img src="img/pykanren6.PNG" style="width: 80%; max-width: 480px;"></p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="sequencel" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>SequenceL</strong></h2>
          <p>
            SequenceL es un lenguaje de programación funcional de propósito general que permite
            la paralelización automática, su objetivo principal es mejorar el rendimiento de los
            procesadores con varios núcleos. Es un lenguaje, que, aunque tiene muchas herramientas
            de paralelización, está enfocado en la facilidad de programación para el usuario.
            Su principal ventaja es que permite escribir código común, y el software se encarga de
            maximizar el rendimiento del procesador, por medio de programación paralela. Sin embargo,
            aunque parece un lenguaje perteneciente a otro tipo de paradigma de programación, se
            caracteriza porque basa su lógica en hechos, reglas y consultas. Lo cuál lo hace un
            lenguaje con mucho potencial y muy diferente a los otros lenguajes aquí mencionados.
          </p>
          <p> A continuación, una pequeña tabla que muestra las diferencias entre SequenceL y
            otro lenguaje popular, Java, permitiendonos ver la facilidad de escritura de código:
          </p>
          <p style=" display: flex; justify-content: center;"><img src="img/sequenceL001.PNG" style="width: 100%; max-width: 840px;"></p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="datalog" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Datalog</strong></h2>
          <p>
            pyDatalog agrega el paradigma de programación lógica a la extensa caja de herramientas de Python.
            Los programadores lógicos ahora pueden usar la extensa biblioteca estándar de Python, y los programadores de
            Python ahora pueden expresar algoritmos complejos rápidamente.
          </p>
          <p>
            Datalog es un lenguaje verdaderamente declarativo derivado de Prolog, con sólidos fundamentos académicos.
            Datalog sobresale en la gestión de la complejidad. Los programas de registro de datos son más cortos que su
            equivalente de Python, y las declaraciones de registro de datos se pueden especificar en cualquier orden,
            tan simple como una fórmula en una hoja de cálculo.
          </p>
          <b>Ejemplo:</b>
          <p style=" display: flex; justify-content: center;"><img src="img/DatalogExample.jpg" style="width: 90%; max-width: 600px;"></p>
          <p style=" display: flex; justify-content: center;"><img src="img/DatalogOut1.jpg" style="width: 90%; max-width: 600px;"></p>
          <p style=" display: flex; justify-content: center;"><img src="img/DatalogOut2.jpg" style="width: 90%; max-width: 600px;"></p>
          <p style=" display: flex; justify-content: center;"><img src="img/DatalogOut3.jpg" style="width: 90%; max-width: 600px;"></p>
        </div>
      </div>
    </section><!-- #content -->

    <!--==========================
        Content Section
        ============================-->
    <section id="ejemplos" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Otros ejemplos</strong></h2>
          <ul>
            <li> Grafos dirigidos en Prolog, busqueda de caminos:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/prolog001.PNG" style="width: 100%; max-width: 1000px;"></p>
            </li>
            <li> Serie Fibonacci en Prolog:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/prolog002.PNG" style="width: 100%; max-width: 1000px;"></p>
            </li>
            <li> Serie Fibonacci en Mercury:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/prolog003.PNG" style="width: 100%; max-width: 1000px;"></p>
            </li>
            <li> Juego de ahorcado en ProLog:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/prolog004.PNG" style="width: 100%; max-width: 1000px;"></p>
            </li>
            <li> Algoritmo merge sort en ProLog:<br><br>
              <p style=" display: flex; justify-content: center;"><img src="img/merge3.PNG" style="width: 100%; max-width: 1000px;"></p>
              <p style=" display: flex; justify-content: center;"><img src="img/sol.PNG" style="width: 50%; max-width: 300px;"></p>
            </li>
          </ul>
        </div>
      </div>
    </section><!-- #content -->

    <section id="ejemplo_comparativo" style="margin-top:50px;">
      <div class="container">
        <div class="text_cell_render border-box-sizing rendered_html">
          <h2 class="title"><strong>Ejemplo comparativo</strong></h2>
          <p>Implementación de un árbol familiar o genealógico por medio de tres lenguajes de programación lógica diferentes.
            El objetivo es descubrir las similitudes y diferencias entre algunos de los lenguajes más populares de la programación lógica.
            Supongamos que tenemos el siguiente árbol familiar:
          </p>
          <p class="p-4" style=" display: flex; justify-content: center; background-color: #333333;"><img src="img/arbol.png" style="width: 100%; max-width: 600px;"></p>

          <p>Primero, veremos la implementación y modelado del ejemplo en Prolog:</p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>% Hechos<br>
            padre(luis, ana).<br>
            padre(luis, jose).<br>
            padre(luis, juan).<br>
            padre(cesar, pedro).<br>
            padre(cesar, david).<br>
            padre(jose, sofia).<br>
            madre(maria, ana).<br>
            madre(maria, jose).<br>
            madre(maria, juan).<br>
            madre(ana, pedro).<br>
            madre(ana, david).<br>
            madre(isabel, sofia).<br><br>
            % Reglas<br>
              hermano(X, Y) :-<br>
                &emsp;padre(Z, X),<br>
                &emsp;padre(Z, Y),<br>
                &emsp;madre(W, X),<br>
                &emsp;madre(W, Y),<br>
                &emsp;X \= Y.<br><br>
              abuelo(Abuelo, Nieto) :-<br>
                &emsp;padre(Abuelo, Hijo),<br>
                &emsp;padre(Hijo, Nieto);<br>
                &emsp;padre(Abuelo, Hijo),<br>
                &emsp;madre(Hijo, Nieto).<br><br>
              abuela(Abuela, Nieto) :-<br>
                &emsp;madre(Abuela, Hijo),<br>
                &emsp;madre(Hijo, Nieto);<br>
                &emsp;madre(Abuela, Hijo),<br>
                &emsp;padre(Hijo, Nieto).
            </code>
          </p>

          <p>Veamos ahora la implementación y modelado del ejemplo en Mercury:</p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>
            :- module relaciones_familiares.<br>
            :- interface.<br>
            :- import_module list.<br>
            <br>
            :- type padre ---> luis; cesar; jose.<br>
            <br>
            :- type madre ---> maria; ana; isabel.<br>
            <br>
            :- type persona ---> luis; cesar; jose; maria; ana; isabel; juan; pedro; david; sofia.<br>
            <br>
            :- type relacion ---> padre(persona, persona); madre(persona, persona).<br>
            <br>
            :- func relaciones_familiares = list(relacion).<br>
            relaciones_familiares =<br>
                [<br>
                    &emsp;padre(luis, ana), padre(luis, jose), padre(luis, juan),<br>
                    &emsp;padre(cesar, pedro), padre(cesar, david),<br>
                    &emsp;padre(jose, sofia),<br>
                    &emsp;madre(maria, ana), madre(maria, jose), madre(maria, juan),<br>
                    &emsp;madre(ana, pedro), madre(ana, david),<br>
                    &emsp;madre(isabel, sofia)<br>
                ].<br>
            <br>
            :- func hermano(persona, persona) = bool.<br>
            hermano(X, Y) :-<br>
                &emsp;padre(Z, X), padre(Z, Y),<br>
                &emsp;madre(W, X), madre(W, Y),<br>
                &emsp;X \= Y.<br>
            <br>
            :- func abuelo(persona, persona) = bool.<br>
            abuelo(Abuelo, Nieto) :-<br>
                &emsp;( padre(Abuelo, Hijo), padre(Hijo, Nieto) ;<br>
                &emsp;padre(Abuelo, Hijo), madre(Hijo, Nieto) ).<br>
            <br>
            :- func abuela(persona, persona) = bool.<br>
            abuela(Abuela, Nieto) :-<br>
                &emsp;( madre(Abuela, Hijo), madre(Hijo, Nieto) ;<br>
                &emsp;madre(Abuela, Hijo), padre(Hijo, Nieto) ).<br>
            <br>
            :- implementation.<br>
            :- import_module string.</code>
          </p>

          <p>Por último, veremos la implementación y modelado del ejemplo en CycL:</p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>; Definición de relaciones familiares<br>
            <br>
            (#$isa #$Luis #$Padre)<br>
            (#$isa #$Cesar #$Padre)<br>
            (#$isa #$Jose #$Padre)<br>
            (#$isa #$Maria #$Madre)<br>
            (#$isa #$Ana #$Madre)<br>
            (#$isa #$Isabel #$Madre)<br>
            <br>
            (#$padreDe #$Luis #$Ana)<br>
            (#$padreDe #$Luis #$Jose)<br>
            (#$padreDe #$Luis #$Juan)<br>
            (#$padreDe #$Cesar #$Santiago)<br>
            (#$padreDe #$Cesar #$David)<br>
            (#$padreDe #$Jose #$Sofia)<br>
            <br>
            (#$madreDe #$Maria #$Ana)<br>
            (#$madreDe #$Maria #$Jose)<br>
            (#$madreDe #$Maria #$Juan)<br>
            (#$madreDe #$Ana #$Santiago)<br>
            (#$madreDe #$Ana #$David)<br>
            (#$madreDe #$Isabel #$Sofia)<br>
            <br>
            ; Reglas de relaciones familiares<br>
            <br>
            (#$and<br>
              &emsp;(#$hermanoDe ?X ?Y)<br>
              &emsp;(#$padreDe ?Z ?X)<br>
              &emsp;(#$padreDe ?Z ?Y)<br>
              &emsp;(#$madreDe ?W ?X)<br>
              &emsp;(#$madreDe ?W ?Y)<br>
              &emsp;(#$notEqual ?X ?Y)<br>
            )<br>
            <br>
            (#$or<br>
              &emsp;(#$abueloDe ?Abuelo ?Nieto)<br>
              &emsp;(#$and<br>
                &emsp;&emsp;(#$padreDe ?Abuelo ?Hijo)<br>
                &emsp;&emsp;(#$padreDe ?Hijo ?Nieto)<br>
              &emsp;)<br>
              &emsp;(#$and<br>
                &emsp;&emsp;(#$padreDe ?Abuelo ?Hijo)<br>
                &emsp;&emsp;(#$madreDe ?Hijo ?Nieto)<br>
              &emsp;)<br>
            )</code>
          </p>

          <h3>Comparación</h3>
          <p>Cada uno de los lenguajes define primero un conjunto de hechos estableciendo reglas entre los elementos involucrados.
            Para el caso de Prolog y CycL, se definen tuplas que establecen una relación entre los elementos listados.
            Con Prolog, se da el nombre a la relación y se pasan como parámetros los elementos de dicha relación:
          </p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>% Hechos<br>
            padre(luis, ana).<br>
            padre(luis, jose).<br>
            padre(luis, juan).<br>
            padre(cesar, pedro).<br>
            padre(cesar, david).<br>
            padre(jose, sofia).<br>
            madre(maria, ana).<br>
            madre(maria, jose).<br>
            madre(maria, juan).<br>
            madre(ana, pedro).<br>
            madre(ana, david).<br>
            madre(isabel, sofia).
            </code>
          </p>
          <p>De esta manera, con la sentencia <code>padre(X, Y).</code> establecemos que el elemento X es el padre del elemento Y; 
            de manera análoga, con la sentencia <code>madre(X, Y).</code> establecemos que el elemento X es la madre del elemento Y.<br>
            Para CycL la estructura es similar:
          </p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>; Definición de relaciones familiares<br>
            <br>
            (#$isa #$Luis #$Padre)<br>
            (#$isa #$Cesar #$Padre)<br>
            (#$isa #$Jose #$Padre)<br>
            (#$isa #$Maria #$Madre)<br>
            (#$isa #$Ana #$Madre)<br>
            (#$isa #$Isabel #$Madre)<br>
            <br>
            (#$padreDe #$Luis #$Ana)<br>
            (#$padreDe #$Luis #$Jose)<br>
            (#$padreDe #$Luis #$Juan)<br>
            (#$padreDe #$Cesar #$Santiago)<br>
            (#$padreDe #$Cesar #$David)<br>
            (#$padreDe #$Jose #$Sofia)<br>
            <br>
            (#$madreDe #$Maria #$Ana)<br>
            (#$madreDe #$Maria #$Jose)<br>
            (#$madreDe #$Maria #$Juan)<br>
            (#$madreDe #$Ana #$Santiago)<br>
            (#$madreDe #$Ana #$David)<br>
            (#$madreDe #$Isabel #$Sofia)
            </code>
          </p>
          <p>En este caso, en CycL primero establecemos relaciones para definir que ciertos elementos son Padre o Madre de otros elementos, 
            mediante el uso de las sentencias <code>(#$isa #$X #$Padre)</code> y <code>(#$isa #$Y #$Madre)</code>. Posteriormente, se establecen
            las relaciones con los demás elementos por medio de las sentencias <code>(#$padreDe #$X #$Y)</code> y <code>(#$madreDe #$P #$Q)</code>,
            que indican que X es padre de Y y P es madre de Q, respectivamente.<br>
            Mercury define primero tipos para luego establecer las relaciones de una forma similar a los otros lenguajes:
          </p>

          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>
            :- type padre ---> luis; cesar; jose.<br>
            <br>
            :- type madre ---> maria; ana; isabel.<br>
            <br>
            :- type persona ---> luis; cesar; jose; maria; ana; isabel; juan; pedro; david; sofia.<br>
            <br>
            :- type relacion ---> padre(persona, persona); madre(persona, persona).<br>
            <br>
            :- func relaciones_familiares = list(relacion).<br>
            relaciones_familiares =<br>
                [<br>
                    &emsp;padre(luis, ana), padre(luis, jose), padre(luis, juan),<br>
                    &emsp;padre(cesar, pedro), padre(cesar, david),<br>
                    &emsp;padre(jose, sofia),<br>
                    &emsp;madre(maria, ana), madre(maria, jose), madre(maria, juan),<br>
                    &emsp;madre(ana, pedro), madre(ana, david),<br>
                    &emsp;madre(isabel, sofia)<br>
                ].</code>
          </p>

          <p>Las sentencias <code>type</code> definen los tipos de elementos del problema, e incluso definen la estructura de las relaciones padre y madre.
            Para establecer las relaciones concretas, se define una función que construye un listado con las tuplas de elementos para cada relación.
          </p>
          <p>Luego de establecer los hechos, cada lenguaje se encarga de definir las reglas del problema. Vamos a comparar la manera en la que se define la 
            regla "hermano" (se entiende que dos personas son hermanas si tienen el mismo padre y la misma madre). Prolog implementa la regla de la siguiente manera:
          </p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>
              hermano(X, Y) :-<br>
                &emsp;padre(Z, X),<br>
                &emsp;padre(Z, Y),<br>
                &emsp;madre(W, X),<br>
                &emsp;madre(W, Y),<br>
                &emsp;X \= Y.
            </code>
          </p>
          <p>La regla "hermano" recibe dos parámetros, X y Y. Las dos primeras sentencias de la regla, <code>padre(Z, X)</code> y <code>padre(Z, Y)</code>,
            verifican que exista una relación que establezca que Z es el padre tanto de X como de Y. Las siguientes dos reglas, <code>madre(W, X)</code> y <code>madre(W, Y)</code>,
            verifican que otro elemento W sea la madre de X y, al mismo tiempo, la madre de Y. Aunque en teoría ya se podría deducir que X es hermano de Y, aún queda el caso
            en el que X y Y sean la misma persona. La última sentencia de la regla, <code>X \= Y.</code>, descarta esta posibilidad, indicando que X y Y deben ser personas
            diferentes para que la regla "hermano" finalmente se cumpla.
          </p>
          <p>Aunque la sintaxis varía un poco en los lenguajes Mercury y CycL, las reglas se definen de manera muy similar:
          </p>
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>
            :- func hermano(persona, persona) = bool.<br>
            hermano(X, Y) :-<br>
                &emsp;padre(Z, X), padre(Z, Y),<br>
                &emsp;madre(W, X), madre(W, Y),<br>
                &emsp;X \= Y.</code>
          </p>
          
          <p class="mx-5 py-3 px-4" style="background-color: #F8F9FA;"><code>
            (#$and<br>
              &emsp;(#$hermanoDe ?X ?Y)<br>
              &emsp;(#$padreDe ?Z ?X)<br>
              &emsp;(#$padreDe ?Z ?Y)<br>
              &emsp;(#$madreDe ?W ?X)<br>
              &emsp;(#$madreDe ?W ?Y)<br>
              &emsp;(#$notEqual ?X ?Y)<br>
            )</code>
          </p>

          <p>Las reglas de "abuelo" y "abuela" también se definen de manera muy similar en los tres lenguajes.
          </p>
        </div>
      </div>
    </section>

  </main>

  <!--==========================
    Footer
  ============================-->
  <footer id="footer">
    <div class="container">
      <div class="credits">
        Creado por estudiantes del curso Lenguajes de Programación de la Universidad Nacional de Colombia.
      </div>
    </div>
  </footer><!-- #footer -->

  <a href="#" class="back-to-top"><i class="fa fa-chevron-up"></i></a>

  <!-- JavaScript Libraries -->
  <script src="lib/jquery/jquery.min.js"></script>
  <script src="lib/jquery/jquery-migrate.min.js"></script>
  <script src="lib/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="lib/easing/easing.min.js"></script>
  <script src="lib/wow/wow.min.js"></script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD8HeI8o-c1NppZA-92oYlXakhDPYR7XMY"></script>

  <script src="lib/waypoints/waypoints.min.js"></script>
  <script src="lib/counterup/counterup.min.js"></script>
  <script src="lib/superfish/hoverIntent.js"></script>
  <script src="lib/superfish/superfish.min.js"></script>

  <!-- Contact Form JavaScript File -->
  <script src="contactform/contactform.js"></script>

  <!-- Template Main Javascript File -->
  <script src="js/main.js"></script>

  <!--Ajax script for math expressions-->
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>

</html>